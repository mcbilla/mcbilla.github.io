<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js正则表达式]]></title>
    <url>%2F2018%2F09%2F05%2Fjs%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式具有复杂字符串搜寻，替换，验证等强大功能，最近接触了 js 的正则表达式顺便学习了一下基础，在这里记录一下学习相关资料。 概述下面有两篇文章较为详细地介绍了 js 正则表达式的基础内容和一些实践例子，先直接贴链接，以后有时间再详细介绍内容： JavaScript 正则表达式（实例） 玩转JavaScript正则表达式 补充RexExp 对象RexExp 对象是什么RexExp 对象是一个全局对象，用于存储模式匹配期间找到的对象。 RexExp 对象的写法是 RexExp.$n，RexExp.$1，RexExp.$2……RexExp.$99，一共可以存储 99 个对象。 每次在调用 非全局的（没有 g 修饰）文本匹配方法，例如RegExp.prototype.exec(str)、 String.prototype.match(reg) 或者 String.prototype.replace(reg) 时，当找到匹配项时，RexExp.$1 对应匹配项中第一个括号中的内容，RexExp.$2 对应匹配项中第二个括号中的内容，以此类推。也就是说 RexExp 对象只储存括号里面的内容。 每次找到匹配项都会 更新所有 RexExp 对象，也就是说 RexExp.$1，RexExp.$2……这些对象全都会被更新。 这么说可能有点抽象，看下下面的例子就明白了。 1234567891011var reg1 = /\d(\w)/;var reg2 = /\d(\w)/g;var str = &apos;$1a2b3c4d5e&apos;;//非全局匹配var rs1 = str.match(reg1)console.log(rs1) //[&quot;1a&quot;, &quot;a&quot;, index: 1, input: &quot;$1a2b3c4d5e&quot;]//全局匹配var rs2 = str.match(reg2)console.log(rs2) //[&quot;1a&quot;, &quot;2b&quot;, &quot;3c&quot;, &quot;4d&quot;, &quot;5e&quot;] 在上面非全局匹配中返回的数组信息有 第一个元素 1a 是找到的第一个匹配项。 第二个元素对应 RegExp.$1 存储的内容。因为正则表达式\d(\w) 有一个括号 (\w)，对应匹配项 1a 里面的 a，所以 a 会被存储在 RegExp.$1 中。 index: 1 表示找到匹配项首字符的位置。 input: “1a2b3c4d5e” 表示输入的查找字符串。 但是在全局匹配返回的数组里面，就只有所有的匹配项信息，RegExp对象、index 和 input 这些信息都没有保存。 RexExp 对象怎么用那么这些 RexExp 对象有什么作用呢？其中最重要的一个作用是用子匹配项 RexExp.$n 来替换原来的文本内容。比如我们想把 ‘2016-11-25’ 变成 ‘11/25/2016’，这时候用 RexExp 对象就会非常方便 1&apos;2016-11-25&apos;.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g,&apos;$2/$3/$1&apos;) //&apos;11/25/2016&apos; 例子下面收集了在工作中常用到的一些正则表达式的例子，在这里记录一下以供日后查阅 控制输入框金额的正确性思路是通过动态修改输入框的内容来控制输入金额的合法性，这里的合法性包括 输入的必须数字或者小数点. 整数部分不能是0开头的两位以上数字 小数部分不能超过两位数字 不能包含两个以上小数点 做法是输入框绑定动态输入事件，每次输入内容时候都把内容传进来检查一遍，如果存在不合法的地方进行替换修改，最后把检查完的内容返回输入框显示。这里假设传进来的内容是 value，代码如下： 12345678910var regStrs = [ [&apos;^0(\\d+)$&apos;, &apos;$1&apos;], //禁止录入整数部分两位以上，但首位为0 [&apos;[^\\d\\.]+$&apos;, &apos;&apos;], //禁止录入任何非数字和点 [&apos;\\.(\\d?)\\.+&apos;, &apos;.$1&apos;], //禁止录入两个以上的点 [&apos;^(\\d+\\.\\d&#123;2&#125;).+&apos;, &apos;$1&apos;] //禁止录入小数点后两位以上]for (var i = 0; i &lt; regStrs.length; i++) &#123; var reg = new RegExp(regStrs[i][0]); value = value.replace(reg, regStrs[i][1]);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java封装、继承和多态]]></title>
    <url>%2F2018%2F08%2F12%2Fjava%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[封装、继承和多态是 java 面向对象的三大特性，其中封装是面向对象编程的基础，继承在封装的基础上简化类编程和提高类的可复用性，并为多态的实现提供了前提，三大特性体现了面向对象编程的思想。在这里简单介绍一些基础知识，转载请说明出处。 封装封装是什么封装把方法和数据包围起来，控制方法和数据的访问级别，隐藏了类的内部实现机制，只向外界暴露特定的访问接口。外界只能通过这些公开的接口来访问数据。 封装的作用：对于类内部，保护私有数据不被轻易破坏，提高了类调用的安全性；对于类外部，调用者不需要了解类内部的具体实现细节，只需要根据接口的规则进行调用，简化编程过程，提高了模块的可复用性和可维护性。 深入封装1、访问权限java 通过访问权限修饰符来控制类、属性和方法的可见范围，访问权限修饰符一共有四种，可见范围从大到小排列如下： public: 所有类都可访问 无修饰符(default): 同一个包的类可访问（包括子类和非子类） protected: 子类可访问（包括直接子类和间接子类） private: 只有本身内部可访问 在这里需要注意的是，子类继承父类时会继承父类的所有域和方法（包括 private 域和 private 方法），但是子类不能访问这些私有域和方法，看起来相当于没有继承一样。 属性和方法可以使用以上四种修饰符，类只能使用 public 和 default 两种修饰符。 2、构造器当创建一个对象时，系统会为这个对象的实例进行默认的初始化，例如把基本类型数值类型的属性设为 0，把布尔类型的属性设为 false，把引用属性设为 null 等等。通过构造器我们可以改变这种默认的初始化，把指定属性初始化为指定值。 构造器有以下特点： 构造器必须和类同名。 构造器不是方法，不能被继承。 构造器没有返回值，也不允许出现返回值。如果出现返回值编译器不会报错，但是就不是构造器了，只是一个跟类同名的普通方法。 构造器只能用 public、default、protected 或 private 四种访问限制修饰符，不能用其他的修饰符。例如 static（构造器总是关联具体对象使用，没必要使用 static）、final（构造器不会被继承，没必要使用 final 限制继承）、abstract（抽象类不能直接实例化）。 可以在一个构造器里面通过 this 关键字来调用另一个构造器，该调用必须写在第一行，不能在普通方法里面调用构造器。 参考 java中构造器（Constructor） 3、thisthis 关键字用来表示当前对象本身。this 关键字的用法如下： 在构造方法中通过 this 关键字来调用其他构造方法，该调用必须放在第一行。 通过 this 关键字来访问类中的所有成员变量和方法，不受访问权限的控制，包括 private 成员和 static 成员。不过由于 static 成员可以通过类名直接访问，如果通过 this 来访问会有 “The static field ××× should be accessed in a static way” 的警告信息。不能在类的 static 成员或 static 块中使用 this。 表示当前类对象的引用，可作为参数传递。 参考 Java this 关键字用法 4、static被 static 关键字修饰的属性和方法不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。static 的作用是在没有创建对象的情况下来进行调用属性或方法。static 可以用来修饰类的成员方法、类的成员变量，另外可以编写 static 代码块来优化程序性能。 1）static 方法static 方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有 this 的，因为它不依附于任何对象，既然都没有对象，就谈不上 this 了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。 如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为 static。我们最常见的 static 方法就是 main 方法，至于为什么 main 方法必须是 static 的，现在就很清楚了。因为程序在执行 main 方法的时候没有创建任何对象，因此只有通过类名来访问。 2）static 变量static 变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static 成员变量的初始化顺序按照定义的顺序进行初始化，也就是说静态代码块和静态变量的级别是相同的，按照出现的顺序初始化。 3）static 代码块static 代码块（包括静态方法）可以置于类中的任何地方，类中可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。因为这个特性可以将一些只需要进行一次的初始化操作都放在 static 代码块中进行，可以优化程序性能。 参考 Java中的static关键字解析 5、类初始化和类实例化类初始化：类第一次加载到内存，虚拟机将类变量（static 修饰的变量）分配内存并设置零值的过程。在类初始化阶段，执行类构造器 &lt;cinit&gt;() 方法。&lt;cinit&gt;() 类初始化方法有如下特点： 编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码和 static {} 域的代码，收集在一起成为 &lt;cinit&gt;() 方法； 子类初始化时会首先调用父类的 &lt;cinit&gt;() 方法； JVM 会保证 &lt;cinit&gt;() 方法的线程安全，保证同一时间只有一个线程执行； 类实例化：类完全加载到内存之后创建对象的过程。在类实例化阶段会调用 &lt;init&gt;() 方法，过程如下： JVM 收集实例初始化变量和 {} 域组合成实例初始化方法 &lt;init&gt;()； 实例初始化时首先执行 &lt;init&gt;() 方法，然后执行构造函数； 子类通过构造函数构造实例时会首先调用父类的 &lt;init&gt;() 方法和父类的构造函数，如果没有显示调用父类的构造函数，那么 JVM 会自动调用父类的无参构造函数，保证父类构造函数一定被调用，然后再是子类自己的 &lt;init&gt;() 方法和构造函数； 至此，实例就构造完毕了； 所以类初始化和类实例化的过程是： 父类类初始化 &lt;cinit&gt;()； 子类类初始化 &lt;cinit&gt;()； 父类 &lt;init&gt;() + 父类构造器； 子类 &lt;init&gt;() + 子类构造器； 最后，具体执行顺序可以总结为 “先静态后非静态，先父类后子类”： 父类静态变量和静态代码块（先声明的先执行）； 子类静态变量和静态代码块（先声明的先执行）； 父类的变量和代码块（先声明的先执行）； 父类的构造函数； 子类的变量和代码块（先声明的先执行）； 子类的构造函数。 这个执行顺序在面试题里面经常会看到，可以记一下。 参考 Java 类初始化（详解）Java（静态）变量和（静态）代码块的执行顺序 继承继承是什么继承是当两个类存在 IS-A 关系的时候，例如人类和男人/女人，学生和小学生/中学生/大学生，后者属于前者的一个特殊分类的时候，就可以在父类的基础上定义一个子类来继承它，子类会自动继承父类的所有属性和方法（会继承但是不一定有权限访问，例如父类的私有域和私有方法）。如下图所示 1234567891011class Human &#123; ......&#125;class Man extends Human &#123; ......&#125;class Woman extends Human &#123; ......&#125; 子类 Man 和 Woman 分别通过关键字 extends 继承父类 Human，这样子类就可以访问父类的有权限访问的属性和方法了。 继承的作用：提高了代码的可复用性，大大减少代码量，并且使类之间产生强依赖关系，为多态的实现提供前提。 深入继承1、子类构造器在调用子类构造器之前会自动调用父类的构造器。在这里有两种情况： 子类构造器里显示调用父类构造器。通过 super() 调用父类无参构造器或者 super(arg1…) 调用父类有参构造器。使用 super 调用父类构造器必须写在子类构造器的第一行，否则编译器会报错。因为上面说过通过 this 调用本类的其他构造器也必须写在第一行，所以不能在同一个构造器里面同时通过 super 和 this 调用构造器。 子类构造器没有显示调用父类构造器。这时编译器会自动调用父类的无参构造器，即会自动在第一行调用 super()。如果父类没有无参构造器，编译报错。 所以为了防止子类编译报错，我们在写父类的时候最好都加上无参构造器，就算是空方法体也行。 2、supersuper 是用来访问父类的成员，作用和 this 类似： 在构造器里面通过 super 来调用父类的构造方法，该调用必须写在子类构造器的第一行。 访问有可见权限的父类的成员变量和方法，不能访问父类的 private 成员。例如当子类中出现和父类同名的成员变量或方法时，父类的成员会被隐藏，这时候可以通过 super 来访问父类中隐藏的成员。如果子类中没有重写父类的成员变量和成员方法，则子类会继承父类的所有非 private 的成员变量和成员方法。这时在子类中无论通过 this 来访问成员和通过 super 来访问成员，结果都是一样的。 请注意 super 和 this 的区别：this 是当前对象的一个引用，所以可以直接把 this 赋值给另外一个对象引用，例如 Object o = this，但是 super 只是一个指示编译器访问父类成员的特殊关键字，不是一个对象引用，Object o = super 这样的写法是错误的。 3、final在 Java 中，final 关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。 修饰类，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注意 final 类中的所有成员方法都会被隐式地指定为 final 方法。 修饰方法，表明方法不能被覆盖。类的 private方 法会隐式地被指定为 final 方法。 修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 参考 浅析Java中的final关键字 4、抽象类抽象类是指 abstract 关键字修饰的类，子类通过 extends 关键字继承抽象类。 抽象类是对普通类的抽象，我们可以把只有概念但是没有具体实现的信息添加到抽象类里面，然后再让继承类来具体实现这些信息。注意抽象类有以下特点： 不能用抽象类来实例化对象。但是可以用抽象类来声明变量，然后用该抽象类的实现子类来实例化对象。 抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。 抽象类里面可以不包含任何 abstract 方法。（这样的抽象类其实没有什么意义，暂且当作概念来记住），但是只要包含一个以上 abstract 方法，该类就必须定义为抽象类。 抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为 public。 抽象类可以包含普通的成员变量和方法，即变量可以定义为任何类型，方法可以有具体实现。 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。 例如下面这个例子： 123456789101112131415161718192021222324252627abstract class AbstractClass &#123; //父类抽象类 private String name; //可以包含普通成员变量 public void CommonMethod() &#123; //可以包含有具体实现的普通方法 //some method &#125; abstract public void AbstractMethod1(); //没有实现的抽象方法（注意后面没有中括号） abstract public void AbstractMethod2();&#125;abstract class NonImplementClass extends AbstractClass &#123; //没有完全实现父类抽象方法的类也必须定义为抽象类 public void AbstractMethod1() &#123; System.out.println(&quot;实现了父类的第一个抽象方法&quot;); &#125;&#125;class ImplementClass extends AbstractClass &#123; //实现了父类所有抽象方法的类不用定义为抽象类 public void AbstractMethod1() &#123; System.out.println(&quot;实现了父类的第一个抽象方法&quot;); &#125; public void AbstractMethod2() &#123; System.out.println(&quot;实现了父类的第二个抽象方法&quot;); &#125;&#125; 5、接口接口是对抽象类的进一步抽象，但是接口不是类。接口用 interface 来修饰，实现类通过 implements 来实现接口，子接口通过 extends 来继承父接口。 接口有以下特点： 接口可以定义成员变量，但是所有的成员变量都会隐式指定为 public static final 变量（并且只能是 public static final 变量，用 private 修饰会报编译错误），所以我们一般不在接口定义成员变量。 接口的方法都会隐式指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现。 实现接口的非抽象类必须要实现该接口的所有方法，如果没有完全实现接口的所有方法就要被定义为抽象类。 例如下面这个例子： 12345678910111213141516171819interface Interface &#123; //父接口 String name = &quot;这是一个常量&quot;; //变量隐式用public static final修饰，所以必须赋初值 void method(); //方法隐式用public abstract修饰&#125;interface ChildInterface extends Interface &#123; //子接口通过extends继承父接口&#125;abstract class ImplementClass1 implements Interface &#123; //没有实现接口所有方法的类必须定义为抽象类&#125;class ImplementClass2 implements Interface &#123; //实现接口所有方法的类不用定义为抽象类 public void method() &#123; //因为接口方法隐式用public abstract修饰，所以这里必须加上public修饰符 System.out.println(&quot;实现接口的方法&quot;); &#125;&#125; 6、抽象类和接口的区别1）语法层面上的区别 抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的； 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 2）设计层面上的区别 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口 Fly，包含方法 fly( )，然后 Airplane和 Bird 分别根据自己的需要实现 Fly 这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板A设计了 ppt B和ppt C，ppt B和ppt C公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 下面看一个网上流传最广泛的例子：门和警报的例子：门都有 open( ) 和 close( ) 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： 1234abstract class Door &#123; public abstract void open(); public abstract void close();&#125; 或者： 1234interface Door &#123; public abstract void open(); public abstract void close();&#125; 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 从这里可以看出， Door 的 open() 、close() 和 alarm() 根本就属于两个不同范畴内的行为，open() 和 close() 属于门本身固有的行为特性，而 alarm() 属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含 alarm() 行为,Door 设计为单独的一个抽象类，包含 open 和 close 两种行为。再设计一个报警门继承 Door 类和实现 Alarm 接口。 1234567891011121314151617181920interface Alram &#123; void alarm();&#125;abstract class Door &#123; void open(); void close();&#125;class AlarmDoor extends Door implements Alarm &#123; void oepn() &#123; //.... &#125; void close() &#123; //.... &#125; void alarm() &#123; //.... &#125;&#125; 以上参考 深入理解Java的接口和抽象类java提高篇（四）—–抽象类与接口 多态多态是什么多态是指当当一个变量用父类类型声明，但用子类类型实例化，该变量在编译阶段会表现为父类类型，在运行阶段会表现为子类类型，会使用子类类型的方法。例如下面这个例子： 12345678910111213141516171819202122232425262728class Human &#123; public void eat() &#123; //父类的 eat 方法 ... &#125;&#125;class Woman extends Human &#123; @Override public void eat() &#123; //Human 类重写 eat() 方法 ... &#125;&#125;class Man extends Human &#123; public void eat() &#123; //Man 类重写 eat() 方法 ... &#125;&#125;public class HumanTest &#123; public static void main(String[] args) &#123; Human human = new Woman(); human.eat(); //会调用 Woman 类的 eat() 方法 human = new Man(); human.eat(); //会调用 Man 类的 eat() 方法 &#125;&#125; 上面例子我们可以看到，一个用父类类型 Human 声明的变量 human 调用 eat() 方法，当该变量用子类 Woman 实例化时会调用 Woman 的 eat() 方法，用子类 Man 实例化时会调用 Man 的 eat() 方法，同一个类型声明的变量可以调用不同子类型的方法，具体调用哪个类的方法要等运行阶段实例化对象的时候才能确定，这就是多态性。 深入多态1、动态绑定和静态绑定绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对 java 来说，绑定分为 静态绑定 和 动态绑定；或者叫做前期绑定和后期绑定。 静态绑定： 在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。针对 Java 简单的可以理解为程序编译期的绑定。java 当中的方法只有 final，static，private 和构造方法是前期绑定。 动态绑定： 在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。 java 方法的调用过程： 编译器查看对象的声明类型和方法名（对象变量的声明类型），通过声明类型找到方法列表。 编译器查看调用方法时提供的参数类型。如果方法是 private、static、final或者构造器，编译器就可以确定调用那个方法。这是静态绑定。 如果不是上述情况，就要使用运行时（动态）绑定。在程序运行时，采用动态绑定意味着：虚拟机将调用对象实际类型所限定的方法。具体过程如下： 动态绑定的过程： 虚拟机提取对象的实际类型的方法表； 虚拟机搜索方法签名； 调用方法。 总结： 在 java 中，几乎所有的 方法（不是字段属性）都是后期绑定（动态绑定），除了 private、static、final 修饰的方法。 对于 static 方法和 final 方法由于不能被继承，因此在编译时就可以确定他们的值，他们是属于前期绑定（静态绑定）的。 对于 private 声明的方法和成员变量不能被子类继承，所有的 private 方法都被隐式的指定为 final。由此我们也可以知道：将方法声明为 final 类型的一是为了防止方法被覆盖，二是为了有效的关闭 java 中的动态绑定。 参考 java的动态绑定与静态绑定(彻底理解多态与重载) 2、向上转型和向下转型向上转型：父类引用指向子类对象 好处：父类声明的变量（包括实参和形参）引用子类对象，可以直接调用子类对象中的方法，这样用一种类型声明的变量就可以调用其所有子类的方法，代码比较简介灵活。否则要调用子类的方法，有多少个子类就要声明多少种类型的变量。 坏处：父类声明的对象只能调用子类重写父类的方法，子类内其他自定义的方法会丢失。 向下转型：父类引用指向子类对象后，再把父类引用类型转换类型后赋值给子类引用 好处：可以调用子类中所有的方法 坏处：可能会存在类型转换失败，在编译时能通过，但是运行会出错，为了安全的类型转换，最好先用 if(A instanceof B) 判断一下。 3、重载和重写重载（OverLoad） ：一个类中定义了多个方法名相同，参数的类型或者数量不同的方法 参数列表必须改变(参数个数或类型不一样)； 返回类型可以改变； 访问修饰符可以改变； 可以声明新的或更广的检查异常； 返回值类型不能作为重载函数的区分标准。 方法能够在同一个类中或者在一个子类中被重载。 重写（Override） ：子类定义了和父类方法名相同、参数个数类型相同、返回值相同的方法。 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问修饰符可以改变，但是不能做更严格的限制（可以降低限制） 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 总结：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 方法名 参数列表 返回类型 访问修饰符 异常 重写 必须相同 必须相同 必须相同 可以不同（不能做更严格的限制） 可以减少或删除，一定不能抛出新的或者更广的异常 重载 必须相同 必须不同（类型或个数不同） 可以不同 可以不同 可以不同 简单来说，重写靠方法名、参数列表和返回值三个相同的判断，重载只靠方法名相同来判断，访问修饰符和异常均不能作为判断依据。 3、多态的三个必要条件 存在继承关系 子类要重写父类的方法 父类类型的引用指向子类对象（向上转型） 看下面这个例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Animal &#123; int num = 10; static int age = 20; public void eat() &#123; System.out.println(&quot;动物吃饭&quot;); &#125; public static void sleep() &#123; System.out.println(&quot;动物在睡觉&quot;); &#125; public void run() &#123; System.out.println(&quot;动物在奔跑&quot;); &#125;&#125;class Cat extends Animal &#123; int num = 80; static int age = 90; String name = &quot;tomCat&quot;; public void eat() &#123; System.out.println(&quot;猫吃饭&quot;); &#125; public static void sleep() &#123; System.out.println(&quot;猫在睡觉&quot;); &#125; public void catchMouse() &#123; System.out.println(&quot;猫在抓老鼠&quot;); &#125;&#125;public class AnimalTest &#123; public static void main(String[] args) &#123; Animal am = new Cat(); am.eat(); am.sleep(); am.run(); //am.catchMouse(); //这里需要注释掉，因为am不能调用子类特有的方法catchMouse() //System.out.println(am.name); //这里需要注释掉，因为am不能调用子类特有的属性name System.out.println(am.num); System.out.println(am.age); &#125;&#125; 以上的三段代码充分体现了多态的三个前提，即： 存在继承关系Cat 类继承了 Animal 类 子类要重写父类的方法子类重写(override)了父类的两个成员方法 eat()，sleep()。其中 eat() 是非静态的，sleep() 是静态的（static）。 父类数据类型的引用指向子类对象。（向上转型）测试类 Demo_Test1 中 Animal am = new Cat();语句在堆内存中开辟了子类 (Cat) 的对象，并把栈内存中的父类 (Animal) 的引用指向了这个 Cat 对象。到此，满足了 Java 多态的的必要三个前提。 输出结果如下：12345猫吃饭动物在睡觉动物在奔跑1020 可以看出来子类 Cat 重写了父类 Animal 的非静态成员方法 am.eat() 的输出结果为：猫吃饭。子类重写了父类 (Animal) 的静态成员方法 am.sleep() 的输出结果为：动物在睡觉未被子类（Cat）重写的父类（Animal）方法 am.run() 输出结果为：动物在奔跑 总结：成员变量（包括静态和非静态）和静态方法，编译看父类，运行看父类只有非静态的成员方法，编译看父类，运行看子类 但是多态有一个弊端：多态后不能使用子类特有的成员属性和成员方法。例如上面的 12am.catchMouse();System.out.println(am.name); 在编译器期间会报错，因为 am 对象不能去获取子类特有的方法 catchMouse() 和属性 am.name。如果一定要调用子类特有的方法和方法，需要把父类引用转成子类类型，也就是向下转型。 12((Cat)am).catchMouse(); //强转成 Cat 类型再调用编译就不会报错了System.out.println(((Cat)am).name); //强转成 Cat 类型再调用编译就不会报错了 参考 JAVA的多态用几句话能直观的解释一下吗？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型理解]]></title>
    <url>%2F2018%2F07%2F25%2Fjava%E6%B3%9B%E5%BD%A2%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[泛型在 Java 中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。在这里简单介绍个人学习 Java 泛型设计过程中的心得总结，如有错误希望大佬们指出。 概述1、什么是泛型泛型的本质是 类型参数（type parameter），即把类型当一个参数来定义和传递使用。 我们平时最熟悉的参数是变量参数，即是在方法头声明里面定义变量形参，在使用的时候再传递实参。 类似于变量参数，类型参数化即把类型由具体的类型参数化（类型形参），在使用的时候再传入具体的类型（类型实参）。这样我们通过传入不同的类型参数就可以创建功能相同，仅仅类型不同的各种类或者方法。这种参数类型可以用在类、接口和方法中，分别被称为 泛型类、泛型接口、泛型方法。 2、为什么要用泛型假如我们想要实现一个 String 数组，并且要求它可以动态改变大小，这时我们都会想到用 ArrayList 来聚合 String 对象。然而，过了一阵，我们想要实现一个大小可以改变的 Date 对象数组，这时我们当然希望能够重用之前写过的那个针对 String 对象的 ArrayList 实现。 在Java 5之前，ArrayList的实现大致如下： 123456public class ArrayList &#123; public Object get(int i) &#123; ... &#125; public void add(Object o) &#123; ... &#125; ... private Object[] elementData;&#125; 从以上代码我们可以看到，用于向 ArrayList 中添加元素的 add 函数接收一个 Object 型的参数，从 ArrayList 获取指定元素的 get 方法也返回一个 Object 类型的对象，Object 对象数组 elementData 存放这 ArrayList 中的对象， 也就是说，无论你向 ArrayList 中放入什么类型的类型，到了它的内部，都是一个 Object 对象。 基于继承的泛型实现会带来两个问题：第一个问题是有关 get 方法的，我们每次调用 get 方法都会返回一个 Object 对象，每一次都要强制类型转换为我们需要的类型，这样会显得很麻烦；第二个问题是有关 add 方法的，假如我们往聚合了 String 对象的 ArrayList 中加入一个 File 对象，编译器不会产生任何错误提示，而这不是我们想要的。 所以，从 Java 5 开始，ArrayList 在使用时可以加上一个类型参数（type parameter），这个类型参数用来指明 ArrayList 中的元素类型。类型参数的引入解决了以上提到的两个问题，如以下代码所示： 12345ArrayList&lt;String&gt; s = new ArrayList&lt;String&gt;();s.add(&quot;abc&quot;);String s = s.get(0); //无需进行强制转换s.add(123); //编译错误，只能向其中添加String对象... 在以上代码中，编译器“获知” ArrayList 的类型参数 String 后，便会替我们完成强制类型转换以及类型检查的工作。 泛型的分类1、泛型类1）定义泛型类（generic class）是具有一个或多个类型变量的类。类型变量用尖括号 &lt;&gt; 括起来，并放在类名后面。泛型类可以有多个类型变量，多个类型变量之前用逗号 , 隔开。 泛型类中可以用定义的泛型变量指定 方法的返回类型 或者 类变量和局部变量 的类型等。 类型变量命名常用 E 表示集合的元素类型，K 和 V 表示关键字和值类型，T（或者 U、S ）表示任意类型。 123456789101112131415161718192021222324252627//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Pair&lt;T, U&gt; &#123; private T first; private U second; public Pair(T first, U second) &#123; this.first = first; this.second = second; &#125; public T getFirst() &#123; return first; &#125; public U getSecond() &#123; return second; &#125; public void setFirst(T newValue) &#123; first = newValue; &#125; public void setSecond(U newValue) &#123; second = newValue; &#125;&#125; 上面的代码中我们可以看到，泛型类 Pair 的类型参数为 T、U，放在类名后的尖括号中。类中可以使用 T 和 U 表示类变量类型或者方法返回类型等如 private T first。 2）使用在实例化泛型类时，我们需要把具体类型当作实参传递进来。注意泛型的参数类型只能是类类型，不能是简单类型。如 1Pair&lt;String, Integer&gt; pair = new Pair&lt;String, Integer&gt;(); 在 Java 7 版本以后，编译器可以根据变量声明里面的具体类型自动推断出构造函数的具体类型，也就是说构造函数可以省略具体类型，我们可以这样写： 1Pair&lt;String, Integer&gt; pair = new Pair&lt;&gt;(); 3）继承泛型类也可以被继承，但是使用效果不是很好。一般用 泛型通配符 代替使用，后面详细介绍。 123class PairChild&lt;T, U, S&gt; extends Pair&lt;T, U&gt; &#123; //可以继承父类的泛型类型并添加新的泛型类型，但是不经常用&#125; 2、泛型接口1）定义泛型接口 (generic interface)和泛型类的使用基本类似，在接口名后加 &lt;&gt; 括起来的类型变量，例如 123public interface Generator&lt;T&gt; &#123; public T next();&#125; 2）实现未传入泛型实参 1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 传入泛型实参 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 3、泛型方法1）定义泛型方法 是指 &lt;&gt; 括起来的类型变量放在修饰符（如 public static）后面，返回类型前面的方法。泛型方法可以定义在普通类中，也可以定义在泛型类中。 12345public class ArrayAlg &#123; public static &lt;T&gt; T getMiddle(T... a) &#123; //传入个数未知的 T 类型变量，T 类型必须为前面 &lt;&gt; 内定义的类型 return a[a.length / 2]; &#125;&#125; 上面 getMiddle 就是一个在普通类 ArrayAlg 里面声明的泛型方法。在方法内可以使用定义的类型变量 T 来作为返回类型或者变量类型。 注意，方法头在返回值前面没有&lt;&gt; 括起来的类型变量都不是泛型方法。例如下面这个方法不是泛型方法： 123public static void getMiddle(Pair&lt;String, Integer&gt; param) &#123; //该方法只是使用了泛型类型的参数的普通方法，不是泛型方法&#125; 2）使用我们可以在方法名前传入具体类型来调用，如： 1ArrayAlg.&lt;String&gt;getMiddle(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); // 编译器提示 Explicit type arguments can be inferred 上面警告实际上是由于 Java 7 以后编译器可以通过传入的变量实参推断出所需要的具体类型，所以我们可以简化成这样的写法： 1ArrayAlg.getMiddle(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); 但是这种写法有一种弊端就是如果传入了不符合要求的类型，编译器也不会报错，在运行阶段才会抛出异常。解决办法是采用第一种调用方法，即在方法名前加具体类型。 123ArrayAlg.getMiddle(&quot;aa&quot;, &quot;bb&quot;, 111); //编译器通过，但是如果我们希望传入的都是 String 类型的参数，最后一个整形参数可能会产生异常ArrayAlg.&lt;String&gt;getMiddle(&quot;aa&quot;, &quot;bb&quot;, 111); //编译器提示错误，可以在编译阶段就发现错误 可以看下这个具体一点的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return &quot;fruit&quot;; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return &quot;apple&quot;; &#125; &#125; class Person&#123; @Override public String toString() &#123; return &quot;Person&quot;; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 4、泛型限定 extends在有些情况下，泛型类或者泛型方法想要对自己的类型参数进一步加一些限制。比如，我们想要限定类型参数只能为某个类的子类或者只能为实现了某个接口的类。我们可以用到 边界限定符 extends。我们可以这样写 1&lt;T extends BoundingType&gt; 其中 BoundingType 是一个类或者接口，可以为一个或多个，多个之间用 &amp; 连接。 1&lt;T extends BoundingType1 &amp; BoundingType2 &amp; BoundingType3&gt; 类添加限定符 1234567public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125;&#125; 接口添加限定符 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; 方法添加限定符 1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); T test = container.getKey(); return test;&#125; 5、泛型通配符1）什么是通配符假设有两个类 Manager 和 Employee，其中 Manager 是 Employee 的一个子类。那么 List&lt; Manager &gt; 是 List&lt; Employee &gt; 的一个子类吗？事实上 List&lt; Manager &gt; 和 List&lt; Employee &gt; 之间没有任何关系。这样会导致可以使用 List&lt; Employee &gt; 的地方不一定能使用 List&lt; Manager &gt;，尽管逻辑上应该是两者都可以使用的。例如下面： 1234567891011121314151617181920class Employee &#123;...&#125; //员工类class Manager extends Employee&#123;...&#125; //管理层类，继承员工类class Company &#123; public void traverse(List&lt;Employee&gt; list) &#123; //遍历员工，理论上应该也可以用该方法来遍历管理层 for(Employee item : list) &#123;&#125; &#125; public void test () &#123; List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); //员工集合 //添加员工 List&lt;Manager&gt; managerList = new ArrayList&lt;&gt;(); //管理层集合 //添加管理层 traverse(employeeList); //编译通过 traverse(managerList); //编译不通过 &#125;&#125; 上面这个例子中，可以用来遍历 List&lt; Employee &gt; 的方法却不能用来遍历 List&lt; Manager &gt;。难道我们要为 List&lt; Manager &gt; 再写一个功能相同，只是类型不同的遍历方法吗？Java 的开发人员想出通过 通配符 来解决这个问题。 通配符是指用 ? 来代替具体的类型。这里的 ？相当于一个类型实参，也就是说不需要事先在方法头的返回值前面通过 &lt;&gt; 来说明，可以直接使用。&lt;? extends Class&gt; 表示 Class 类本身和其所有子类型，例如： 1List&lt;? extends Employee&gt; 表示类型参数是 Employee 本身及其子类的所有 List 类型，包括 List&lt; Manager &gt;。通过通配符 List&lt; Employee &gt; 和 List&lt; Manager &gt; 形成了类似于父子关系，这样可以使用 List&lt; Employee &gt; 的地方也可以使用 List&lt; Manager &gt; 了。在上面的例子中我们只需要把遍历方法改一下： 123public void traverse(List&lt;? extends Employee&gt; list) &#123; //可同时遍历员工和管理层 for(Employee item : list) &#123;...&#125;&#125; 这时候我们调用 traverse(employeeList) 和 traverse(managerList) 都会编译通过。 &lt; T extends Class &gt; 和 &lt; ? extends Class &gt; 这两个有什么区别呢？最主要的区别是 T 是类型形参，? 是类型实参。使用 T 的话需要在方法头的返回值前面通过 &lt;T&gt; 声明才能在后面使用，使用 ? 的话可以跟 Integer 等实参一样不需要声明随时使用，下面两个方法可以实现相同的效果。 1234567public void traverse1(List&lt;? extends Employee&gt; list) &#123; //使用通配符 ? for(Employee item : list) &#123;...&#125;&#125;public &lt;T extends Employee&gt; void traverse2(List&lt;T&gt; list) &#123; 使用泛型 T for(Employee item : list) &#123;...&#125;&#125; 2）超类型限定 super通配符比类型变量还多了一个功能：通过关键字 super 可以指定超类型限定(supertype bound)。这个功能跟 extends 恰好相反。&lt;? super Class&gt; 表示 Class 类本身和其所有超类型。注意没有 &lt; T super Class &gt; 这样的写法。例如： 1&lt;? super Manager&gt; 表示所有 Manager 本身及其所有父类类型。 3）PECS 原则通配符上界 extends假如有一个 list 的类型为 List&lt;? extends Class&gt;，Class 相当于类型上界。 当我们从 list 获取元素时，因为 Class 是父类型，我们可以用父类型来转换所有的子类型对象，这是符合 Java 继承规则的。 当我们往 list 添加元素时，因为 list 里面每个对象的类型是未知的，有的可能是顶级父类类型 Class，有的可能是其他的子孙类型 ClassChild。ClassChild 一般会在 Class 的基础上扩展增加了很多其他方法。假设我们可以添加成功，那么当我们再取出 list 元素的时候，我们只能知道该元素的顶级父类类型是 Class，但是我们没办法知道该元素在添加前是什么类型以及有哪些方法可以调用。所以禁止向 &lt;? extends Class&gt; 类型添加对象 ，除了 null。 1234public void modify1 (List&lt;? extends Employee&gt; list) &#123; list.add(new Employee()); //编译失败 Employee employee = list.get(0); //编译通过&#125; 通配符下界 super假如有一个 list 的类型为 List&lt;? super Class&gt;，Class 相当于类型下界。 当我们从 list 获取元素时，因为 Class 是最底层的子孙类型，list 里面的元素可能会存在父类类型的元素。在 Java 继承规则里面，子类类型变量不能表示父类类型对象，因此我们不能用 Class 类型来表示任意 list 元素。所以禁止从 &lt;? super Class&gt;类型获取对象，除了 null。 1234public void modify2 (List&lt;? super Manager&gt; list) &#123; list.add(new Manager()); //编译通过 Manager manager = list.get(0); //编译失败&#125; 当我们向 list 添加元素时，因为 Class 是最底层的子类类型，其包括了本身和父类的所有变量和方法。假设可以添加成功，我们可以获取任意元素转换成子类 Class 类型，然后任意调用其本身和父类的变量和方法，这是符合 Java 继承规则的。所以允许向 list 添加元素。 总结根据上面的例子，extends 定义了类型的上界，super 定义了类型的下界，我们可以总结出一条规律，”Producer Extends, Consumer Super”，也就是常说的 PECS 原则： “Producer Extends”：如果你需要一个只读 List，用它来 produce T，那么使用 &lt; ? extends T &gt;。 “Consumer Super”：如果你需要一个只写 List，用它来 consume T，那么使用 &lt; ? super T &gt;。 如果需要同时读取以及写入，那么我们就不能使用通配符了。 阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样： 123456public class Collections &#123; public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; for (int i=0; i&lt;src.size(); i++) dest.set(i, src.get(i)); &#125;&#125; 4）无限定通配符无限定通配符就是没有上下界限定，只有单独的 &lt;?&gt;。如 List&lt;?&gt;，? 可以表示任何类型。无界通配符通常会用在下面两种情况： 当方法是使用原始的Object类型作为参数时，如下： 123456789101112public static void printList(List&lt;Object&gt; list) &#123; for (Object elem : list) System.out.println(elem + &quot;&quot;); System.out.println();&#125;//上面方法可以选择改为如下所示，这样就可以兼容更多的输出，而不单纯是 List&lt;Object&gt;public static void printList(List&lt;?&gt; list) &#123; for (Object elem: list) System.out.print(elem + &quot;&quot;); System.out.println();&#125; 在定义的方法体的业务逻辑与泛型类型无关，如 List.size()，List.clear() 等这些方法。实际上，最常用的就是 Class&lt;?&gt;。 最后提醒一下的就是，List 与 List&lt;?&gt; 并不等同，List 是 List&lt;?&gt; 的子类。不能往 List&lt;?&gt; 里面获取和添加任何元素，除了 null。 深入理解泛型1、类型擦除类型擦除 就是说 Java 泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，把所有类型参数替换为 BoundingType（若未加限定就替换为 Object ）。 这样到了运行期间实际上 JVM 根本不知道泛型所代表的具体类型。这样做的目的是因为 Java 泛型是 1.5 之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。 例如下面这段代码 12345678910public class Node&lt;T&gt; &#123; private T data; private Node&lt;T&gt; next; public Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; public T getData() &#123; return data; &#125; // ...&#125; 编译器做完相应的类型检查之后会把类型进行擦除，因为没有限定类型，所以替换为 Object 类型。实际上到了运行期间上面这段代码会变成： 12345678910public class Node &#123; private Object data; private Node next; public Node(Object data, Node next) &#123; this.data = data; this.next = next; &#125; public T getData() &#123; return data; &#125; // ...&#125; 如果我们设置了限定类型，如下所示： 12345678910public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123; private T data; private Node&lt;T&gt; next; public Node(T data, Node&lt;T&gt; next) &#123; this.data = data; this.next = next; &#125; public T getData() &#123; return data; &#125; // ...&#125; 这样编译器就会将 T 出现的地方替换成 Comparable 而不再是默认的 Object 了： 12345678910public class Node &#123; private Comparable data; private Node next; public Node(Comparable data, Node next) &#123; this.data = data; this.next = next; &#125; public Comparable getData() &#123; return data; &#125; // ...&#125; 不管原来声明的是 List&lt; String &gt; 还是 List&lt; Integer &gt;，类型擦除之后都会变成 List&lt; Object &gt;，所以两者在编译完成后的 Class 类型是相同的，看下面这个例子： 1234567List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();System.out.println(classStringArrayList.equals(classIntegerArrayList)) //输出 true，证明类型擦除后两者的 class 类型相同。 2、桥方法桥方法（Bridge Method）是用来解决继承泛型类型中的多态问题的。我们先来看下面这个例子。 123456789101112131415public class Pair&lt;T&gt; &#123; private T first; public void setFirst(T first)&#123; this.first = first; &#125; public Object getFirst()&#123; return this.first; &#125; &#125;class SonPair extends Pair&lt;String&gt;&#123; public void setFirst(String first)&#123;...&#125;&#125; 在这里程序猿传入类型 String 来继承 Pair 类并想覆盖父类中的 setFirst() 方法，但事实上子类没有办法覆盖这个方法。因为父类 Pair 在编译阶段已经被类型擦除，变成了 1234567public class Pair &#123; private Object first; public void setFirst(Object first)&#123; this.first = first; &#125;&#125; 子类中的 setFirst(String first) 方法不能覆盖父类的 setFirst(Object first) 方法。为了解决这个问题，就需要用到桥方法。桥方法简单来说就是 生成一个跟父类方法头相同的方法，该方法把参数转换类型后再调用子类的方法。 12345678//实际上子类生成了两个方法class SonPair extends Pair&lt;String&gt;&#123; public void setFirst(Object first)&#123; setFirst((String) first) &#125; public void setFirst(String first)&#123;...&#125;&#125; 这样可以解决泛型继承的多态问题。对于 getFirst() 方法，子类也生成了两个方法。 123456789class SonPair extends Pair&lt;String&gt;&#123; public Object getFirst()&#123; return this.first; &#125; public String getFirst()&#123; return this.first; &#125;&#125; 根据 Java 的多态继承规则，在同一个类里面不能定义两个方法名和参数完全相同的方法，所以我们在写代码的时候写两个这样的方法，编译器肯定是不能通过的。但是注意：JVM 会用参数类型和返回类型来确定一个方法。 一旦编译器通过某种方式自己编译出方法签名一样的两个方法(只能编译器自己来创造这种奇迹，我们程序员却不能人为的编写这种代码)。JVM 还是能够分清楚这些方法的，前提是需要返回类型不一样。 3、注意事项1）不允许创建泛型数组Java 不支持创建泛型数组。假设如果允许创建泛型数组，会出现下面这种情况： 1234567Object[] stringLists = new List&lt;String&gt;[]; // compiler error, but pretend it&apos;s allowedstringLists[0] = new ArrayList&lt;String&gt;(); // OKstringLists[1] = new ArrayList&lt;Integer&gt;(); // An ArrayStoreException should be thrown, but the runtime can&apos;t detect it.String s = stringLists[1].get(0); // Run-time error: ClassCastException. 假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道 new ArrayList&lt; String &gt;() 和 new ArrayList&lt; Integer &gt;() 的区别，他们可以被添加到同一个数组里面 List[] 里面。只有当运行时取出元素的时候进行类型转换时才会报 ClassCastException 的异常。为了避免这种情况我们不允许创建泛型数组，让编译器去帮助我们检查就可以避免这种情况。 2）不能利用类型参数创建实例Java 不允许类型类型参数创建实例，例如下面这种情况： 1234public static &lt;E&gt; void append(List&lt;E&gt; list) &#123; E elem = new E(); // compile-time error list.add(elem);&#125; 主要还是由于类型擦除的问题，在运行阶段实际上我们会创建一个 Object 对象，违背了我们只想创建特定类型的对象的初衷。但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题： 1234public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123; E elem = cls.newInstance(); // OK list.add(elem);&#125; 3）不能用基本类型实例化类型参数对于数据类型，类型参数只支持 Integer 等包装类型，不支持 int 等基本类型。 123List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //OKList&lt;int&gt; list2 = new ArrayList&lt;&gt;(); //compile error, Type argument cannot be of primitive type 4）不能抛出也不能捕获泛型类实例泛型类扩展 Throwable 即为不合法，因此无法抛出或捕获泛型类实例。但在异常声明中使用类型参数是合法的： 12345678910public static &lt;T extends Throwable&gt; void doWork(T t) throws T &#123; try &#123; ... &#125; catch (T e) &#123; //compile error, cannot catch type parameters Logger.global.info(e.getMessage()); &#125; catch (Throwable realCause) &#123; //OK t.initCause(realCause); throw t; &#125;&#125; 5）泛型类的静态上下文中不能使用类型变量泛型类里面的静态变量和方法不能直接使用类上定义的类型变量，如果静态方法要使用泛型，必须将静态方法也定义成泛型方法： 12345678class StaticGenerator&lt;T&gt; &#123; private static T name; //compilr error public static T getName()&#123; return null;&#125;; //compilr error public static &lt;T&gt; T getNamebyGeneric() &#123;return null;&#125; //OK&#125; 6）不能对泛型使用 instanceof不能对泛型代码直接使用 instanceof 关键字，因为编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的 JVM 在运行时期无法识别出 ArrayList&lt; Integer &gt; 和 ArrayList&lt; String &gt;的之间的区别： 12345public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123; if (list instanceof ArrayList&lt;Integer&gt;) &#123; // compile error // ... &#125;&#125; 总结 泛型的本质是类型参数，即把类型当作一个参数来使用。在实例化泛型时再把具体类型当作实参传递进来。泛型的用途有泛型类、泛型接口和泛型方法等。 泛型的用途是在编译阶段限制对象类型，这样可以避免在运行阶段出现类型转换异常。 泛型类是具有一个或多个类型变量的类。类型变量用尖括号 &lt;&gt; 括起来，并放在类名后面。泛型类可以有多个类型变量，多个类型变量之前用逗号 , 隔开。 泛型接口和泛型类的使用基本类似，在接口名后加 &lt;&gt; 括起来的类型变量。 泛型方法是指 &lt;&gt; 括起来的类型变量放在修饰符（如 public static）后面，返回类型前面的方法。泛型方法可以定义在普通类中，也可以定义在泛型类中。 子类型限定符 extends 用于限制类型上界。 通配符 ? 用于实现两个泛型集合之间的父子关系。通配符有 PECS 原则。 超类型限定符 super 是通配符特有的，用于限制类型下界。 类型擦除是指编译器生成的代码会擦除相应的类型信息，把所有类型参数替换为 BoundingType（若未加限定就替换为 Object ）。 桥方法是用来解决继承泛型类型中的多态问题的。 不允许创建泛型数组。 不能利用类型参数创建实例。 不能用基本类型实例化类型参数。 不能抛出也不能捕获泛型类实例。 泛型类的静态上下文中不能使用类型变量。 不能对泛型使用 instanceof。 参考java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一Java泛型详解JVM如何理解Java泛型类(转)Java核心技术点之泛型Java 通配符解惑]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js时间操作]]></title>
    <url>%2F2018%2F07%2F23%2Fjs%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[总结了 js 中常用的时间操作和格式化的方法，在这里记录一下以供日后查阅。 js 时间初始化和常用方法初始化时间1、获取系统当前时间1var date = new Date() //获取当前系统时间 返回一个表示系统当前时间的 Date 对象。 2、根据整数参数初始化格式： new Date(year, month, date, hour, minute, second)说明： 按给定的参数创建 Date 对象，参数范围如下： 参数 范围 year 四位整数表示年份，如果提供两位整数默认补全 19 开头 month 0-11 表示 1到12月份 date 1-31 表示 1到31日 hour 0-23 表示 1到24小时 minute 0-59 表示 1到60分钟 second 0-59 表示 1到60秒 例如： 12345var date = new Date(2018, 01, 01) //Thu Feb 01 2018 00:00:00 GMT+0800 (中国标准时间)var date = new Date(2018, 01, 01, 01) //Thu Feb 01 2018 01:00:00 GMT+0800 (中国标准时间)var date = new Date(2018, 01, 01, 01, 01, 01, 01) //Thu Feb 01 2018 01:01:01 GMT+0800 (中国标准时间) 3、根据字符串参数初始化格式： new Date(&#39;year-month-day hour:minute:second&#39;)说明： 通过字符串内容来创建 Date 对象，日期部分可以写成 &#39;year-month-day&#39;，&#39;year month day&#39;，&#39;year/month/day&#39; 和 &#39;year.month.day&#39;等格式，时间部分写成 &#39;hour:minute:second&#39;，两部分以空格隔开，最常用的写法是 &#39;year-month-day hour:minute:second&#39;例如： 12345var date = new Date(&apos;2018-02-02&apos;) //Fri Feb 02 2018 08:00:00 GMT+0800 (中国标准时间)var date = new Date(&apos;2018/02/02&apos;) //Fri Feb 02 2018 08:00:00 GMT+0800 (中国标准时间)var date = new Date(&apos;2018-02-02 02:02:02&apos;) //Fri Feb 02 2018 02:02:02 GMT+0800 (中国标准时间) 4、根据时间戳参数初始化 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。时间戳唯一地标识某一刻的时间。 格式： new Date(timestamp)说明： 通过时间戳来创建 Date 对象，时间戳可以为负数，表示 1970 年以前的时间例如： 123var date = new Date(1520017383000) //Sat Mar 03 2018 03:03:03 GMT+0800 (中国标准时间)var date = new Date(-1520017383000) //Tue Nov 01 1921 12:56:57 GMT+0800 (中国标准时间) 常用方法1、set 方法1234567date.setTime() -------以毫秒设置时间date.setDate() -------设置月中某一天(1-31)date.setMonth() -------设置年中某一月(0-11)date.setFullYear() ----设置年份(4位数,2位数不支持了)date.setHours() -------设置某一天中小时(0-23)date.setMinutes() ---设置某一小时中分钟(0-59)date.setSeconds() ---设置某一小时中秒数(0-59) 2、get 方法12345678910date.getDate() -------获取月中某一天(1-31)date.getMonth() -------获取年中某一月(0-11)date.getDay() -------获取星期中某一天的编号(0-6),星期天为0date.getFullYear() ---获取四位数年份(2位数被代替了)date.getHours() -------获取天中的小时(0-23)date.getMinutes() ---获取小时中分钟(0-59)date.getSeconds() ---获取分钟中秒(0-59)date.getMillSeconds() -获取毫秒值(0-999)date.getTime() -------获取时间戳Date.parse(&apos;str&apos;) ---解析 str 字符串返回时间戳 3、toString 类方法123456date.toString() ----------返回日期时间，如 Mon Jul 24 2017 14:47:31 GMT+0800 (中国标准时间)date.toTimeString() -------返回时间，如 14:49:06 GMT+0800 (中国标准时间)date.toDateString() -------返回日期，如 Mon Jul 24 2017date.toLocaleString() -----返回本地化的日期时间，如 2017/7/24 下午2:51:34date.toLocaleDateString() -返回本地化的日期，如 2017/7/24date.toLocaleTimeString() -返回本地化的时间，如 下午2:52:32 日期时间格式化原生 js 并没有格式化日期时间的方法，需要发开人员自己写方法来格式化日期。 最简单的写法思路是获取需要格式化日期的 Date 对象，调用该对象的 get 类方法获取单独部分，最后再把单独部分拼装成完整的日期时间。 123456789101112131415//昨天的时间var day1 = new Date();day1.setTime(day1.getTime()-24*60*60*1000); //1、时间戳day1.setDate(day1.getDate() - 1); //2、通过 get、set 方法var s1 = day1.getFullYear()+&quot;-&quot; + (day1.getMonth()+1) + &quot;-&quot; + day1.getDate();//今天的时间var day2 = new Date();var s2 = day2.getFullYear()+&quot;-&quot; + (day2.getMonth()+1) + &quot;-&quot; + day2.getDate();//明天的时间var day3 = new Date();day3.setTime(day3.getTime()+24*60*60*1000); //1、时间戳day3.setDate(day3.getDate() + 1); //2、通过 get、set 方法var s3 = day3.getFullYear()+&quot;-&quot; + (day3.getMonth()+1) + &quot;-&quot; + day3.getDate(); 封装格式化方法封装格式化方法，传入格式化字符串参数如 yyyy-MM-dd HH:mm:ss 可返回格式化后的日期。在网上找到两个方法，记录一下。 1、第一个方法为 Date 原型添加方法： 1234567891011121314151617181920Date.prototype.format = function(fmt) &#123; var o = &#123; &quot;M+&quot; : this.getMonth()+1, //月份 &quot;d+&quot; : this.getDate(), //日 &quot;h+&quot; : this.getHours(), //小时 &quot;m+&quot; : this.getMinutes(), //分 &quot;s+&quot; : this.getSeconds(), //秒 &quot;q+&quot; : Math.floor((this.getMonth()+3)/3), //季度 &quot;S&quot; : this.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) &#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length)); &#125; for(var k in o) &#123; if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length))); &#125; &#125; return fmt; &#125; 使用如下： 123var time1 = new Date().format(&quot;yyyy-MM-dd hh:mm:ss&quot;); //2018-07-23 12:13:14var time2 = new Date().format(&quot;yyyy-MM-dd&quot;); ////2018-07-23 2、第二个方法传入需要被格式化的日期 date 和格式化字符串 datestr，其中 datestr 必须为以下格式 yyyy-MM-dd yyyy/MM/dd yyyy-MM-dd hh:mm:ss yyyy/MM/dd hh:mm:ss hh:mm:ss 1234567891011121314151617181920212223242526272829303132333435function formateDate (date, dateStr) &#123; if(typeof date === &quot;number&quot;)&#123; var d=new Date(); d.setTime(date); date=d; &#125; var arr=dateStr.split(/\/|-|:| /); //分割字符串,- / : 空格 var timeArr=[]; for (var i = 0; i &lt; arr.length; i++) &#123; //按照需要将日期放入数组timeArr switch (arr[i]) &#123; case &quot;yyyy&quot;: timeArr.push(date.getFullYear()); break; case &quot;MM&quot;: timeArr.push(date.getMonth()+1); break; case &quot;dd&quot;: timeArr.push(date.getDate()); break; case &quot;hh&quot;: timeArr.push(date.getHours()); break; case &quot;mm&quot;: timeArr.push(date.getMinutes()); break; case &quot;ss&quot;: timeArr.push(date.getSeconds()); break; &#125; &#125; for (var i = 0; i &lt;arr.length; i++) &#123; dateStr = dateStr.replace(arr[i],timeArr[i]); &#125; return dateStr;&#125; 参考js获取当前时间(昨天、今天、明天)JS日期格式化转换方法JavaScript 时间操作js 初始化日期对象 new Date() 常用方式]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>时间操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架总结]]></title>
    <url>%2F2018%2F07%2F12%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前对 Java 集合框架的了解仅仅停留在知道怎么使用一些常见集合，对集合框架的使用也没有做深一步的研究，经常被种类繁多的集合框架弄得云里雾里。现在对 Java 集合框架的设计思想和原理进行进一步学习，希望更加熟练灵活地掌握集合框架进而提高我们的开发效率。 前言在 Java 2 之前，Java 是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如 Vector，Stack，Hashtable 等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在 Java 2 中，Java 设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。 从上面我们可以看到 Java 集合框架主要有 Collection 和 Map 两种类型的容器接口，再下面是一些子接口或者抽象类，最后是具体实现类。： Collection 集合接口：存储单个元素数据，下面有 3 个经典的子接口类型 List、Set 和 Queue。 List 代表有序、可重复的集合，常用的实现类有 ArrayList、LinkedList。 Set 代表无序、不可重复的集合，常用的实现类有 HashSet、TreeSet。 Queue 代表先进先出的队列集合，常用的实现类有 ArrayDeque、LinkedList。 Map 映射接口：存储 key-value 对元素数据，其中 key 是不可重复的。常用的实现类有 HashMap、TreeMap 等。 Collection 接口Collection 接口是集合的根接口，定义对集合元素进行操作的通用方法。Collection 的框架图如下所示： Collection 接口定义的所有方法如下所示： 常用的方法有 add() 添加一个元素到集合中，addAll() 将指定集合中的所有元素添加到另外一个集合中，contains() 方法检测集合中是否包含指定的元素，toArray() 方法返回一个表示集合的数组，iterator() 获取集合的迭代器来遍历集合。 遍历 Collection由上图可见 Collection 接口包含 Iterator 变量，且继承了 Iterable 接口，根据官方文档 Implementing this interface allows an object to be the target of the “for-each loop” statement. 所以 Collection 接口下的所有集合都可以通过 for-each 循环 或者 Iterator 迭代器 两种方法进行遍历。对于 List 类集合还可以通过 索引值 来遍历或者获取指定位置的元素。 for-each 循环遍历 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();//往list里面添加元素for(String item : list)&#123; //每一次循环把元素放到item变量里面 //对取出的元素进行操作&#125; Iterator 迭代器遍历 1234567List&lt;String&gt; list = new ArrayList&lt;&gt;();//往list里面添加元素Iterator&lt;String&gt; iterator = list.iterator();while(iterator.hasNext())&#123; //判断是否有下一个元素 String item = iterator.next(); //取出该元素放到item变量里面 //对取出的元素进行操作&#125; 索引值获取元素 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();//往list里面添加元素for (int i = 0; i &lt; list.size(); i++) &#123; String item = list.get(i); //取出该元素放到item变量里面 &#125; Collection 元素比较Collection 集合的元素比较大小可以通过实现 Comparable 接口 ，然后 覆盖 compareTo(Object obj) 方法。 12345@Overridepublic int compare(Integer o1, Integer o2) &#123; return o1 - o2; //从小到大排序 //return o2 - o1; //从大到小排序&#125; 部分 Collection 集合例如 TreeSet、PriorityQueue 等类已经实现了 Comparable 接口，默认从小到大的自然排序。 如果我们不想用自然排序，像用其他方式进行排序，我们可以新建一个 Comparator 比较器，在创建集合的时候提供 Comparator。 例如下面对 PriorityQueue 中的元素进行比较，并且也可以覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void defaultCompareQueue() &#123; //实现 Comparable 接口的 PriorityQueue 类，默认从小到大的自然排序 PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;(); q1.add(2); q1.add(4); q1.add(9); q1.add(1); while (!q1.isEmpty()) &#123; System.out.print(q1.poll() + &quot;,&quot;); &#125;&#125;public static void defineCompareQueue1() &#123; //自定义一个 Comparator，采用从大到小的降序排序 Comparator&lt;Integer&gt; cmp = new Comparator&lt;Integer&gt;() &#123; public int compare(Integer e1, Integer e2) &#123; return e2 - e1; &#125; &#125;; //在新建集合时候提供上面的 Comparator PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(5, cmp); q2.add(2); q2.add(4); q2.add(9); q2.add(1); while (!q2.isEmpty()) &#123; System.out.print(q2.poll() + &quot;,&quot;); &#125;&#125;public static void defineCompareQueue2() &#123; //初始化集合时直接提供自定义的 Comparator，采用从小到大的降序排序 PriorityQueue&lt;Integer&gt; q3 = new PriorityQueue&lt;&gt;( new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125; ); q3.add(2); q3.add(4); q3.add(9); q3.add(1); while (!q3.isEmpty()) &#123; System.out.print(q3.poll() + &quot;,&quot;); &#125;&#125; 一、ListList 是一个可重复的有序集合。元素会增加到容器中的特定位置。除了常规的 Iterator 迭代器，还增加了能够双向遍历线性表的列表迭代器 ListIterator。List 可以通过 for-each 循环、Iterator 迭代器 和 索引值 三种方法进行访问。 下面介绍 List 接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList 和 LinkedList。 1、ArrayListArrayList 是一个动态扩展的数组。它用数组存储元素，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。因为基于数组的结构，所以 ArrayList 通过索引值来获取指定元素的效率很高。 下面是 ArrayList 初始化的源码部分，从中我们可以看到 ArrayList 创建动态数组的过程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static final int DEFAULT_CAPACITY = 10; //默认容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //默认容量空数组transient Object[] elementData; //用非序列化的数组临时存储元素private int size; //数组长度public ArrayList(int initialCapacity) &#123; //传入容量参数创建 ArrayList，如果容量为0就用默认容量 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125;public ArrayList() &#123; //没有传入容量就创建默认容量数组 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public boolean add(E e) &#123; //向集合中添加指定元素。 ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; //比较所需要的最小容量和目前数组的长度length(不管数组上是否有元素)，如果前者比后者大就新建更大容量的数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; //创建更大容量的数组，然后将旧数组的元素复制到新数组中。 // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; ArrayList 和 Vector 比较ArrayList 和 Vector 的功能非常类似，区别是 ArrayList 是线程不安全的，Vector 是线程安全的，且 Vector 比 Arraylist 的性能要差，尽量少用 Vector类。如果对线程安全没有要求就用 Arraylist，如果有要求可以参考 java.util.concurrent 并发编程包里面的类。 Stack 是 Vector 的子类，用户模拟 “栈” 这种数据结构，“栈” 通常是指 “后进先出” (LIFO) 的容器。最后 “push” 进栈的元素，将被最先 “pop” 出栈。Stack 与 Vector 一样，是线程安全的，但是性能较差，尽量少用 Stack 类。如果要实现栈这种数据结构，可以考虑使用 LinkedList。 2、LinkedListLinkedList 是以链表的形式来保存元素。除此之外，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成栈来使用（实现 Stack 类），也可以当成队列来使用（实现 Queue 类）。 虽然 LinkedList 也是 List 集合，可以根据索引来随机访问集合中的元素。但是通过索引来访问链表的第 n 个元素，必须从头开始遍历完前面的 n-1 个元素才能访问到目标元素，没有捷径可走，所以 LinkedList 随机访问的性能非常差。 下面是 LinkedList 初始化的源码部分，我们可以看到 LinkedList 的数据结构和创建过程。 12345678910111213141516171819202122232425262728293031323334transient int size = 0;transient Node&lt;E&gt; first; //链表保存开始节点和最后节点，用于双向修改链表transient Node&lt;E&gt; last;private static class Node&lt;E&gt; &#123; //每个节点包含元素内容，前驱节点和后驱节点 E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;public boolean add(E e) &#123; //添加元素 linkLast(e); return true;&#125;void linkLast(E e) &#123; //默认在链表最后添加元素 final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; ArrayList 和 LinkedList 比较 ArrayList 随机访问效率高，随机插入、随机删除效率低；LinkedList则反之，随机访问效率低，随机插入、随机删除效率高。 ArrayList 使用随机访问来遍历效率高，LinkedList 使用逐个遍历效率高。 如果需要经常随机插入、删除元素，应使用 LinkedList；如果需要随机快速访问元素，应使用 ArrayList。 二、SetSet 是无序的不允许重复的集合。如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add() 方法返回 false，且新元素不会被加入。 哈希表在介绍 Set 集合之前我们先来认识一下哈希表。 什么是散列表当我们用数组来存储元素，然后通过把元素的关键字通过某个函数映射到数组中的某个位置，然后把元素存储在该位置上。这样我们通过关键字就可以迅速查找到元素的数组位置，然后访问该位置上的元素。这种方式实现的数组就叫做 哈希表 (hash table)，把关键字映射成存储位置的函数就叫做 哈希函数 (hash function)，映射后得到一个整数值叫做 哈希码 (hash code)。如下图所示 哈希冲突当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的 哈希冲突。解决哈希冲突的方法有 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列） 再哈希法 拉链法 建立一个公共溢出区 例如最常用的 拉链法 也被称为 链表的数组。散列表的主干是数组，每一个数组元素都叫做 桶 (bucket)，每个桶存储一个链表，整体看起来就像链表组成的数组。同一个链表上的元素的哈希码相同，不同链表之间的元素的哈希码都不相同。 要插入一个元素，先计算该元素的散列码，然后与桶的总数取余，得到余数 n 就是该元素应插入到第 n 个桶，然后把元素插入到该桶所在位置。如果该位置没有元素就直接插入，如果该位置已经有元素了，遍历该元素所在的链表，通过 equals 方法进行对比，存在即覆盖，不存在就插入到链表末尾。 hashCode 方法和 equals 方法的单方面兼容： 如果 a.equals(b) 为 true，a 和 b 必须有相同的散列码。 如果 a 和 b 有相同的散列码，a.equals(b) 不一定为 true。 Set 有三个常见实现类 TreeSet、HashSet(下面有子类 LinkedHashSet)和 EnumSet。 1、HashSetHashSet 是基于散列表实现的无序 Set 集合。HashSet 中的元素的排序顺序随机分配，所以访问顺序也是随机。 HashSet 的底层是基于 HashMap 实现的，使用 HashMap 来保存所有元素。因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成的。参考 深入Java集合学习系列：HashSet的实现原理 123public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 2、TreeSetTreeSet 和 HashSet 类似，但是它是一个不允许重复的有序 Set 集合。可以将任意顺序将元素插入到集合中，在遍历的时候每个值将自动按照排序后的顺序显示。 TreeSet 使用红黑树的结构来实现排序，每次添加新元素的时候都会从根节点开始跟其他元素进行比较，最终将其放在正确的排序位置上。实际上 TreeSet 的底层是根据 TreeMap 来实现的。 123public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;());&#125; HashSet 和 TreeSet 比较将元素添加到树中比添加到散列表中的速度要慢，所以如果对排序有要求就可以选择 TreeSet，如果无要求就可以选择 HashSet。 三、QueueQueue 用于模拟队列这种数据结构，队列通常是指 先进先出（FIFO）的容器。新元素插入到队列的尾部，访问元素操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 Queue 常用的实现类有 PriorityQueue、Deque 接口下的 ArrayDeque 和 LinkedList。 1、PriorityQueuePriorityQueue 是使用 堆(heap) 结构的实现的队列。堆是一种可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花时间对元素进行排序。 PriorityQueue 中的元素可以按照任意的顺序插入，但是会按队列元素的大小进行重新排序。因此当取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中的最小的元素。 PriorityQueue 本质也是一个动态数组，在这一方面与ArrayList是一致的。PriorityQueue 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY=11）创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable ）。 另外注意： PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。 不允许插入 null 元素。 方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。 2、ArrayDequeDeque 接口是 Queue 接口的子接口，它代表一个双端队列。LinkedList 是以链表实现的双端队列，ArrayDeque 是用数组实现的双端队列。两者都维护表示头尾的两个节点。 ArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。 ArrayDeque 不是线程安全的。当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。 Map 接口Map 是用于保存具有映射关系的数据集合。Map 集合里保存着 key 和 value 两组值，key 和 value 都可以是任何引用类型的数据。Map 的 key 不允许重复，同一个 Map 对象的任何两个 key 通过 equals 方法比较总是返回 false。key 和 value 之间存在单向一对一关系，即通过指定的 key，总能找到唯一的、确定的 value。 Map 接口定义的所有方法如下所示： 从上面我们可以看到 key、value 和 key-value 对应的成员变量如下所示： 12345Set&lt;K&gt; keySet();Collection&lt;V&gt; values();Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); 其中 values 是一个 Collection 集合，keySet 和 entrySet 是一个 Set 集合。但是注意这个 Set 集合也不是 HashSet 或者 TreeSet。这里的 Collection 和 Set 集合被称为 视图 (views)，是其他实现了 Collection 接口和 Set 接口 的类返回的对象。这个视图并没有创建一个新集合，而是返回一个类对象来对原来的映射进行操作。 另外我们还可以看到 Map 接口 比 Collection 接口多提供了一个 Entry 子接口，一般用 Map.Entry&lt;&gt; 来表示 Map 集合 key-value 对元素类型。 遍历 Map遍历 Map 有三种常用方式 遍历 keySet() 12345678910111213 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();//1.for-each 循环遍历 keySet()for (String item : map.keySet()) &#123; //对取出来的每个key进行下一步操作&#125;//2.iterator 迭代器遍历 keySet()Iterator&lt;String&gt; iterator = map.keySet().iterator();while (iterator.hasNext()) &#123; String item = iterator.next(); //对取出来的每个key进行下一步操作&#125; 遍历 values() 12345678910111213 Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();//1.for-each 循环遍历 values()for (Integer item : map.values()) &#123; //对取出来的每个value进行下一步操作&#125;//2.iterator 迭代器遍历 values()Iterator&lt;Integer&gt; iterator = map.values().iterator();while (iterator.hasNext()) &#123; Integer item = iterator.next(); //对取出来的每个value进行下一步操作&#125; 遍历 entrySet() 12345678910111213Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();//1.for-each 循环遍历 entrySet()for (Map.Entry&lt;String, Integer&gt; item : map.entrySet()) &#123; //对取出来的每个entry进行下一步操作&#125;//2.iterator 迭代器遍历 entrySet()Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator2 = map.entrySet().iterator();while (iterator2.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; item = iterator2.next(); //对取出来的每个entry进行下一步操作&#125; 总结： 如果同时需要 key 和 value 的值就用直接遍历 entrySet()，这是最常用的遍历方法。 如果只需要 key 或者 value 的值，就遍历 keySet() 或者 values()，性能上比遍历 entrySet() 要快 10%～20%。 通过遍历 keySet()，根据 key 值来获取对应的 value 值的方式性能最低，应尽量避免使用。 Map 接口下最常用的实现类是 HashMap 和 TreeMap。 1、HashMapHashMap 是基于散列表实现的无序的 Map 集合。实际上 HashMap 是通过 拉链法 也就是数组+链表实现的。数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。 12345678910transient Node&lt;K,V&gt;[] table; //HashMap 的主干是一个 Node 类型的数组static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; //Node节点包含下一个 Node 节点的索引，实际上构成一个链表 final int hash; final K key; V value; Node&lt;K,V&gt; next;......&#125; 在访问 HashMap 的时候 如果定位到的数组位置不含链表（当前 entry 的 next 指向 null ）,那么对于查找，添加等操作很快，仅需一次寻址即可 如果定位到的数组包含链表，对于添加操作，其时间复杂度为 O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过 key 对象的 equals 方法逐一比对查找。 所以，性能考虑，HashMap中的链表出现越少，性能才会越好。具体可以参考 HashMap实现原理及源码分析 HashMap 与 Hashtable 的区别HashMap 和 Hashtable 的功能和实现机制非常类似，Hashtable 是更早期实现的，现在已经很少用了。两者的区别如下，具体可参考 HashMap和HashTable到底哪不同？ Hashtable 是线程安全的，HashMap 是线程不安全的，因此 HashMap 比 Hashtable 的性能更好一些。 HashMap 允许 key 或者 value 的值为 null，而 HashTable 的 key 或者 value 不允许为 null，否则会抛出 NullPointerException 异常。 根据官方注释，HashTable已经被淘汰了，不要在新的代码中再使用它。如果你不需要线程安全，那么使用 HashMap，如果需要线程安全，那么使用 ConcurrentHashMap。 2、TreeMapTreeMap 是基于散列表实现的有序的 Map 集合。TreeMap 会对插入的 key-value 对的 key值进行排序。实际上TreeMap 是基于 红黑树 (Red-Black Tree) 结构实现的，其排序是通过调整树结构来实现的，红黑树的具体知识参考 红黑树(一)之 原理和算法详细介绍。 因为在插入删除元素的时候设计树结构的调整，所以红黑树的插入删除元素性能比较差。 HashMap 和 TreeMap 比较一般的应用场景，尽可能多考虑使用HashMap，因为其为快速查询设计的。如果需要特定的排序时，考虑使用TreeMap。 其他参考Java - 集合框架完全解析由浅入深理解java集合(一)——集合框架 Collection、Map由浅入深理解java集合(二)——集合 Set由浅入深理解java集合(三)——集合 List由浅入深理解java集合(四)——集合 Queue由浅入深理解java集合(五)——集合 Map]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常处理中throw和throws的区别和用法]]></title>
    <url>%2F2018%2F07%2F10%2FJava%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%ADthrow%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前一篇文章已经详细介绍了 Java 的异常处理机制，在这里做一些补充，探讨异常处理关键字 throw 和 throws 的区别和用法。转载请说明出处。 抛出异常的三种形式Java 抛出异常有三种形式： 系统自动抛出异常 方法名通过 throws 抛出异常 方法体通过 throw 抛出异常 系统自动抛出异常当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。发生异常后线程停止运行，后面的语句执行不到，会在包含它的所有 try 块中（可能在上层调用函数中）从里向外寻找含有与其匹配的 catch 子句的 try 块。如： 12345public static void main(String[] args) &#123; int a = 5, b =0; System.out.println(5/b); //function();&#125; 系统会自动抛出ArithmeticException异常： 123Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zeroat test.ExceptionTest.main(ExceptionTest.java:62) 再如 12345public static void main(String[] args) &#123; String s = &quot;abc&quot;; System.out.println(Double.parseDouble(s)); //function();&#125; 系统会自动抛出NumberFormatException异常： 1234567Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;abc&quot;at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1224)at java.lang.Double.parseDouble(Double.java:510)at test.ExceptionTest.main(ExceptionTest.java:62) throw 抛出异常throw 出现在方法体中，用于程序员主动抛出某种特定类型的异常。通过 throw 抛出的异常和系统自动抛出的异常有相同的效果。 12345678910public static void main(String[] args) &#123; String s = &quot;abc&quot;; if(s.equals(&quot;abc&quot;)) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; //function();&#125; 会抛出异常： 123Exception in thread &quot;main&quot; java.lang.NumberFormatExceptionat test.ExceptionTest.main(ExceptionTest.java:67) throws 抛出异常throws 出现方法头中，用来声明该方法可能抛出的异常类型，然后把异常交给调用它的上级程序来处理。 对于 Error 和 RuntimeException 类型的及其子类的异常，不需要在方法头通过 throws 明确声明，因为这是不期待出现的异常。对于其他类型的异常 Java 编译器强制要求在方法头 通过 throws 明确声明，否则编译不通过。 12345678910111213public static void function() throws NumberFormatException&#123; String s = &quot;abc&quot;; System.out.println(Double.parseDouble(s));&#125; public static void main(String[] args) &#123; try &#123; function(); &#125; catch (NumberFormatException e) &#123; System.err.println(&quot;非数据类型不能转换。&quot;); //e.printStackTrace(); &#125;&#125; 输出结果如下： 1非数据类型不能转换。 throw 和 throws 的区别和用法区别 throws 用于方法头，throw 用于方法内部 throws 后跟异常类型，表示可能会出现这些类型的异常，但是不一定抛出；throw 后跟异常对象，如果执行到 throw 就一定会抛出这种类型的异常。 throw 后只能跟一个异常对象，throws 后可以一次声明多种异常类型。 使用场合Java 将派生于 Error 类和 RuntimeException 类的异常称为 非检查异常 (unchecked exception)，将其他异常称为 检查异常 (checked exception)。 一般来说，系统在编译阶段检查的是检查异常和 throws 声明的异常，在运行阶段自动抛出的是非检查异常。 对于检查异常，如果通过 throw 主动抛出，或者调用了可能会产生异常的方法但是又没有进行处理，必须在方法头上用 throws 显式声明该异常类型，否则编译器会报错。如下面 IOException 为检查异常 1234567891011121314151617//通过throw主动抛出public void throwEx1() throws IOException &#123; //正常编译 throw new IOException(&quot;.&quot;); &#125;public void throwEx2() &#123; //编译报错 unhandled exception java.io.ioexeption throw new IOException(&quot;.&quot;);&#125;//调用可能会产生异常的方法但是没有进行处理public void throwEx3() throws IOException&#123; //正常编译 FileInputStream input = new FileInputStream(&quot;xxx&quot;);&#125;public void throwEx4() &#123; //编译报错 unhandled exception java.io.ioexeption FileInputStream input = new FileInputStream(&quot;xxx&quot;);&#125; 对于非检查异常，如果通过 throw 主动抛出，可自行选择是否在方法头用 throws 显式声明，不声明编译也不会报错。如下面 SQLException 为非检查异常 1234567public void throwEx5() throws SQLException&#123; //正常编译 throw new IllegalStateException(&quot;.&quot;);&#125;public void throwEx6() &#123; //正常编译 throw new IllegalStateException(&quot;.&quot;);&#125; 如果调用方法名包含 throws 异常类型的方法，必须在方法内通过 try...catch 捕获，或者继续在方法名上用 throws 声明继续往上抛。例如调用上面的方法 1234567891011public void throwEx7() &#123; throwEx1(); //编译报错 unhandled exception java.io.ioexeption throwEx5(); //编译报错 unhandled exception java.sql.sqlexeption throwEx6(); //正常编译&#125;public void throwEx8() throws IOException, SQLException&#123; throwEx1(); //正常编译 throwEx5(); //正常编译 throwEx6(); //正常编译&#125; 编程总结 在写程序时，对可能会出现异常的部分通常要用 try{...}catch{...} 去捕捉它并对它进行处理 用 try{...}catch{...} 捕捉了异常之后一定要对在 catch{...} 中对其进行处理，那怕是最简单的一句输出语句，或栈输入 e.printStackTrace() 如果是捕捉 IO 输入输出流中的异常，一定要在 try{...}catch{...} 后加 finally{...} 把输入输出流关闭； 如果在函数体内用 throw 抛出了某种异常，最好要在函数名中加 throws 抛异常声明，然后交给调用它的上层函数进行处理。 参考再探java基础——throw与throws百度问答]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常处理详解]]></title>
    <url>%2F2018%2F07%2F10%2FJava%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[之前在学习工作中虽然一直在用 Java 的异常处理，但一直都处于仅仅了解简单用法的表面基础上。最近趁有空进一步深入学习了 Java 的异常处理机制，发现一些写得很好的博客，转载过来学习。本文转载自: https://www.cnblogs.com/lulipro/p/7504267.html 什么是异常异常就是程序运行时，发生的不被期望的事件，阻止了程序按照程序员的预期正常执行。Java 为异常提供了优秀的解决办法：异常处理机制。 异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。 Java 中的异常可以是函数中的语句执行时引发的，也可以是程序员通过 throw 语句手动抛出的，只要在 Java 程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。 Java异常的分类和类结构图Throwable 类是 Java 异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。 Throwable 又派生出 Error 类和 Exception 类。 Error：Error 类以及他的子类的实例，代表了 JVM 本身的错误。错误不能被程序员通过代码处理，Error 很少出现。因此，程序员应该关注 Exception 为父类的分支下的各种异常类。 Exception：Exception 以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被 Java 异常处理机制使用，是异常处理的核心。 根据编译器 Javac 对异常的处理要求（注意是分类是给 javac 识别的），将异常类分为2类。 非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理。这样的异常发生的原因多半是代码写的有问题。如除0错误 ArithmeticException，错误的强制类型转换错误 ClassCastException，数组索引越界 ArrayIndexOutOfBoundsException，使用了空对象 NullPointerException等等。 检查异常（checked exception）：除了 Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作。在方法中要么用 try-catch 语句捕获它并处理，要么用 throws 子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。 下面的代码会演示2个异常类型：ArithmeticException 和 InputMismatchException。前者由于整数除0引发，后者是输入的数据不能被转换为int类型引发。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.example;import java. util .Scanner ;public class AllDemo&#123; public static void main (String [] args ) &#123; System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ; CMDCalculate (); &#125; public static void CMDCalculate () &#123; Scanner scan = new Scanner ( System. in ); int num1 = scan .nextInt () ; int num2 = scan .nextInt () ; int result = devide (num1 , num2 ) ; System . out. println( &quot;result:&quot; + result) ; scan .close () ; &#125; public static int devide (int num1, int num2 )&#123; return num1 / num2 ; &#125;&#125;/*****************************************----欢迎使用命令行除法计算器----0Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero at com.example.AllDemo.devide( AllDemo.java:30 ) at com.example.AllDemo.CMDCalculate( AllDemo.java:22 ) at com.example.AllDemo.main( AllDemo.java:12 )----欢迎使用命令行除法计算器----rException in thread &quot;main&quot; java.util.InputMismatchException at java.util.Scanner.throwFor( Scanner.java:864 ) at java.util.Scanner.next( Scanner.java:1485 ) at java.util.Scanner.nextInt( Scanner.java:2117 ) at java.util.Scanner.nextInt( Scanner.java:2076 ) at com.example.AllDemo.CMDCalculate( AllDemo.java:20 ) at com.example.AllDemo.main( AllDemo.java:12 )*****************************************/ 异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了 异常追踪栈。 异常最先发生的地方，叫做 异常抛出点。 从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。这种行为叫做 异常的冒泡，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。 上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。 代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。 123456789101112131415@Testpublic void testException() throws IOException&#123; //FileInputStream的构造函数会抛出FileNotFoundException FileInputStream fileIn = new FileInputStream(&quot;E:\\a.txt&quot;); int word; //read方法会抛出IOException while((word = fileIn.read())!=-1) &#123; System.out.print((char)word); &#125; //close方法会抛出IOException fileIn.clos&#125; 怎么处理异常在编写代码处理异常时，对于检查异常，有2种不同的处理方式： 使用 try…catch…finally 语句块处理它。 在函数签名中使用 throws 声明 交给函数调用者 caller 去解决。 try…catch…finally语句块123456789101112131415161718192021try&#123; //try块中放可能发生异常的代码。 //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。 //如果发生异常，则尝试去匹配catch块。&#125;catch(SQLException SQLexception)&#123; //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。 //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。 //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。 //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。 //如果try中没有发生异常，则所有的catch块将被忽略。&#125;catch(Exception exception)&#123; //...&#125;finally&#123; //finally块通常是可选的。 //无论异常是否发生，异常是否匹配被处理，finally都会执行。 //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。 //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。&#125; 需要注意的地方： try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。 每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面，这样保证每个catch块都有存在的意义。 java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。 1234567891011public static void main(String[] args)&#123; try &#123; foo(); &#125;catch(ArithmeticException ae) &#123; System.out.println(&quot;处理异常&quot;); &#125;&#125;public static void foo()&#123; int a = 5/0; //异常抛出点 System.out.println(&quot;为什么还不给我涨工资!!!&quot;); //这里后面不会执行&#125; 有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：恢复式异常处理模式（resumption model of exception handling）而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：终结式异常处理模式（termination model of exception handling） throws 函数声明throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。 throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。 采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。 1234public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN&#123; //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。&#125; 异常的链化在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。 异常链化: 以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。 查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。这种设计和链表的结点类设计如出一辙，因此形成链也是自然的了。 12345678910111213141516public class Throwable implements Serializable &#123; private Throwable cause = this; public Throwable(String message, Throwable cause) &#123; fillInStackTrace(); detailMessage = message; this.cause = cause; &#125; public Throwable(Throwable cause) &#123; fillInStackTrace(); detailMessage = (cause==null ? null : cause.toString()); this.cause = cause; &#125; //........&#125; 下面是一个例子，演示了异常的链化：从命令行输入2个int，将他们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出 一个链化的异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static void main(String[] args)&#123; System.out.println(&quot;请输入2个加数&quot;); int result; try &#123; result = add(); System.out.println(&quot;结果:&quot;+result); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;//获取输入的2个整数返回private static List&lt;Integer&gt; getInputNumbers()&#123; List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); Scanner scan = new Scanner(System.in); try &#123; int num1 = scan.nextInt(); int num2 = scan.nextInt(); nums.add(new Integer(num1)); nums.add(new Integer(num2)); &#125;catch(InputMismatchException immExp)&#123; throw immExp; &#125;finally &#123; scan.close(); &#125; return nums;&#125;//执行加法计算private static int add() throws Exception&#123; int result; try &#123; List&lt;Integer&gt; nums =getInputNumbers(); result = nums.get(0) + nums.get(1); &#125;catch(InputMismatchException immExp)&#123; throw new Exception(&quot;计算失败&quot;,immExp); /////////////////////////////链化:以一个异常对象为参数构造新的异常对象。 &#125; return result;&#125;/*请输入2个加数r 1java.lang.Exception: 计算失败 at practise.ExceptionTest.add(ExceptionTest.java:53) at practise.ExceptionTest.main(ExceptionTest.java:18)Caused by: java.util.InputMismatchException at java.util.Scanner.throwFor(Scanner.java:864) at java.util.Scanner.next(Scanner.java:1485) at java.util.Scanner.nextInt(Scanner.java:2117) at java.util.Scanner.nextInt(Scanner.java:2076) at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30) at practise.ExceptionTest.add(ExceptionTest.java:48) ... 1 more*/ 自定义异常如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。 按照国际惯例，自定义的异常应该总是包含如下的构造函数： 一个无参构造函数 一个带有String参数的构造函数，并传递给父类的构造函数。 一个带有String参数和Throwable参数，并都传递给父类构造函数 一个带有Throwable 参数的构造函数，并传递给父类的构造函数。 下面是IOException类的完整源代码，可以借鉴。 12345678910111213141516171819202122232425public class IOException extends Exception&#123; static final long serialVersionUID = 7818375828146090155L; public IOException() &#123; super(); &#125; public IOException(String message) &#123; super(message); &#125; public IOException(String message, Throwable cause) &#123; super(message, cause); &#125; public IOException(Throwable cause) &#123; super(cause); &#125;&#125; 异常的注意事项重写带 throws 声明的父类方法当子类重写父类的带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内。意思是说 子类 throws 的异常数量不能多于父类 子类 throws 的类型必须是父类异常类型或其子类 例如，父类方法 throws 2 个异常，子类就不能 throws 3 个及以上的异常。父类 throws IOException，子类就必须 throws IOException 或者 IOException 的子类。 这是为了支持多态。看下面这个例子 1234567891011121314151617181920212223242526272829303132333435363738class Father&#123; public void start() throws IOException &#123; throw new IOException(); &#125;&#125;class Son extends Father&#123; public void start() throws Exception &#123; throw new SQLException(); &#125;&#125;/**********************假设上面的代码是允许的（实质是错误的）***********************/class Test&#123; public static void main(String[] args) &#123; Father[] objs = new Father[2]; objs[0] = new Father(); objs[1] = new Son(); for(Father obj:objs) &#123; //因为Son类抛出的实质是SQLException，而IOException无法处理它。 //那么这里的try。。catch就不能处理Son中的异常。 //多态就不能实现了。 try &#123; obj.start(); &#125;catch(IOException) &#123; //处理IOException &#125; &#125; &#125;&#125; 异常是线程独立的Java 程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。 也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。 finally 执行不受 try 块中的 return 影响在 try 块中即便有 return，break，continue 等改变执行流的语句，finally 也会执行。 1234567891011121314151617public static void main(String[] args)&#123; int re = bar(); System.out.println(re);&#125;private static int bar()&#123; try&#123; return 5; &#125; finally&#123; System.out.println(&quot;finally&quot;); &#125;&#125;/*输出：finally5*/ 很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。 也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0x80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。 finally 中的 return 会覆盖 try 或者 catch 中的返回值。不管 try 和 catch 里面 return 什么值，都会被 finally 的 return 值所覆盖。 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; int result; result = foo(); System.out.println(result); result = bar(); System.out.println(result);&#125;@SuppressWarnings(&quot;finally&quot;)public static int foo() &#123; try &#123; int a = 5 / 0; &#125; catch (Exception e) &#123; return 1; &#125; finally &#123; return 2; &#125;&#125;@SuppressWarnings(&quot;finally&quot;)public static int bar() &#123; try &#123; return 1; &#125; finally &#123; return 2; &#125;&#125;/*最终输入结果22 */ finally 中的 return 会抑制（消灭）前面 try 或者 catch 块中的异常1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args)&#123; int result; try&#123; result = foo(); System.out.println(result); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //没有捕捉到异常 &#125; try&#123; result = bar(); System.out.println(result); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); //没有捕捉到异常 &#125;&#125;//catch中的异常被抑制@SuppressWarnings(&quot;finally&quot;)public static int foo() throws Exception&#123; try &#123; int a = 5/0; return 1; &#125;catch(ArithmeticException amExp) &#123; throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;); &#125;finally &#123; return 100; &#125;&#125;//try中的异常被抑制@SuppressWarnings(&quot;finally&quot;)public static int bar() throws Exception&#123; try &#123; int a = 5/0; return 1; &#125;finally &#123; return 100; &#125;&#125;/*最终输出：100100*/ finally 中的异常会覆盖（消灭）前面 try 或者 catch 中的异常12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args)&#123; int result; try&#123; result = foo(); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125; try&#123; result = bar(); &#125; catch (Exception e)&#123; System.out.println(e.getMessage()); &#125;&#125;//catch中的异常被抑制@SuppressWarnings(&quot;finally&quot;)public static int foo() throws Exception&#123; try &#123; int a = 5/0; return 1; &#125;catch(ArithmeticException amExp) &#123; throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;); &#125;finally &#123; throw new Exception(&quot;我是finaly中的Exception，覆盖了catch的异常&quot;); &#125;&#125;//try中的异常被抑制@SuppressWarnings(&quot;finally&quot;)public static int bar() throws Exception&#123; try &#123; int a = 5/0; //这里产生的异常被下面finally抛出的异常覆盖 return 1; &#125;finally &#123; throw new Exception(&quot;我是finaly中的Exception，覆盖了try的异常&quot;); &#125;&#125;/*最终输出：我是finaly中的Exception，覆盖了catch的异常我是finaly中的Exception，覆盖了try的异常 */ 上面的3个例子都异于常人的编码思维，因此我建议： 不要在fianlly中使用return。 不要在finally中抛出异常。 减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。 将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序获取openid、session_key和access_token]]></title>
    <url>%2F2018%2F07%2F06%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%B0%83%E6%95%B4%2F</url>
    <content type="text"><![CDATA[openid、session_key 和 access_token 是微信小程序常用到的信息，需要通过官方提供的 api 接口来获取。 openid 是微信用户在公众号 appid 下的唯一用户标识（appid 不同，则获取到的 openid 就不同），可用于永久标记一个用户。 session_key 用于校验用户信息（例如 wx.getUserInfo(OBJECT) 返回的 signature）和解密（例如 wx.getUserInfo(OBJECT) 返回的 encryptedData）。 access_token 是全局唯一接口调用凭据，开发者调用各接口时都需使用。access_token 的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效，所以需要妥善保存。 转载请说明出处。 获取 openid 和 session_key获取用户信息接口调整根究官方公告 获取用户信息接口优化调整，wx.getUserInfo() 进行调整，2018年05月10日以后小程序需要通过 button 按钮授权来引导用户主动进行授权操作才能获取用户信息。 简单来说，在旧接口里面，开发人员可以随时调用 wx.getUserInfo()。在第一次调用的时候会弹出授权窗口，需要用户进行授权操作才能获取信息。 在新接口里面，不能随时调用 wx.getUserInfo()，需要在 button 按钮里面添加属性 open-type=“getUserInfo”，通过点击 button 按钮来弹出授权窗口，用户授权之后两种方法获取用户信息： button 按钮绑定事件 bindgetuserinfo=&quot;methodName&quot;，通过 methodName 事件回调数据来获取用户信息。回调数据 e.detail 数据与 wx.getUserInfo() 返回的一致 xml 1&lt;button open-type=“getUserInfo&quot; bindgetuserinfo=&quot;pageGetUserInfo&quot;&gt;下一步&lt;/button&gt; js 123pageGetUserInfo: function (e) &#123; console.log(e.detail) #detail数据与wx.getUserInfo()返回的一致&#125;, button 按钮绑定普通点击事件 bindtap=&quot;methodName&quot;，在 methodName 方法里面调用 wx.getUserInfo() 来获取用户信息。这时候 button 按钮只是起到弹出授权窗口的作用。 xml 1&lt;button open-type=“getUserInfo&quot; bindtap=&quot;pageGetUserInfo&quot;&gt;下一步&lt;/button&gt; js 12345678pageGetUserInfo: function (e) &#123; var that = this app.getUserInfo(function (userInfo) &#123; that.setData(&#123; userInfo: userInfo &#125;) &#125;)&#125;, app.js 123456789101112131415161718getUserInfo: function (cb) &#123; var that = this if (this.globalData.userInfo) &#123; typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo) &#125; else &#123; wx.login(&#123; success: function (res) &#123; var code = res.code; //获取code wx.getUserInfo(&#123; success: function (res) &#123; //用户授权登录 that.globalData.userInfo = res.userInfo typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125;, &#125;) &#125;&#125;, 获取 openid 和 session_key根据官方提供的 小程序登录 流程，流程图如下： 获取 openid 和 session_key 的步骤可以分为： wx.login() 获取登录临时凭证 code 把 code 通过 wx.request() 发送到我们的开发服务器 在开发服务器上把 code、appid 和 appsecret 发送到微信api https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code。appid 和 appsecret 从 微信公众平台 上获取，然后在开发服务器上定义为配置变量来调用 获取 openid 和 seesion_key 返回 一般来说会在 app.js 里面定义获取用户信息的方法 getUserInfo() 方法，该方法里面再分别调用 wx.login() （返回的 code 用于获取 openid）和 wx.getUserInfo() （返回用户信息，其中 userInfo 可以保存在全局变量 app.globalData.userInfo 里面）。这样全局都可以通过调用 getUserInfo() 来进行获取 openid 和用户信息。 wx.getUserInfo() 返回的数据 encryptedData 包括 openid 等敏感数据的完整用户信息的加密数据，如果只需要 openid 而不需要 session_key 的话可以直接解密 encryptedData 来获取 openid，详见 加密数据解密算法 下面贴出核心代码（并不是完整代码） app.js1234567891011121314151617181920212223242526272829303132333435363738394041getUserInfo: function (cb) &#123; var that = this if (this.globalData.userInfo) &#123; typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo) &#125; else &#123; wx.login(&#123; success: function (res) &#123; var code = res.code; wx.getUserInfo(&#123; success: function (res) &#123; //用户授权登录 that.globalData.userInfo = res.userInfo var encryptedData = encodeURIComponent(res.encryptedData); var iv = res.iv; that.wxLogin(code, encryptedData, iv); //调用后台接口登录 typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo) &#125;, fail: function (res) &#123; //用户没有授权登录 //todo &#125;, &#125;) &#125;, &#125;) &#125;&#125;,wxLogin: function (code, encryptedData, iv) &#123; var that = this var data = &#123; code: code, encryptedData: encryptedData, iv: iv &#125; that.api(&apos;get&apos;, &apos;/index/decodeUserInfo&apos;, data, function(res)&#123; //该方法是自定义对wx.request()进一步封装的request请求方法，添加了异常处理等 that.globalData.openid = res.openid &#125;)&#125;,globalData: &#123; userInfo: null, openid: null,&#125; UserController.java1234567891011121314151617181920212223242526public class UserController &#123; @ResponseBody @RequestMapping(&quot;/index/decodeUserInfo&quot;) public Map decodeUserInfo(@RequestParam Map&lt;String, String&gt; params) &#123; String encryptedData = params.get(&quot;encryptedData&quot;); String iv = params.get(&quot;iv&quot;); String code = params.get(&quot;code&quot;); try &#123; String rs = userService.getWxjscode2session(appIdVersion, code); JSONObject obj = JSONObject.parseObject(rs); String session_key = obj.get(&quot;session_key&quot;).toString(); String openid = obj.get(&quot;openid&quot;).toString(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;openid&quot;, openid); map.put(&quot;session_key&quot;, session_key); return ApiResponse.ok(map); &#125; catch (Exception e) &#123; e.printStackTrace(); log.error(e.getMessage()); return ApiResponse.response(ApiResponse.Code.ERROR, &quot;内部错误。&quot;, e.getMessage()); &#125; &#125;&#125; UserService.java123456789101112131415161718192021222324public class UserService &#123; private final static String wxjscode2sessionURL= &quot;https://api.weixin.qq.com/sns/jscode2session&quot;; private final static String appId = &quot;xxx&quot;; private final static String secret = &quot;xxx&quot;; private final static String grantType = &quot;authorization_code&quot;; public String getWxjscode2session (String appIdVersion, String code)&#123; String rs = &quot;&quot;; try&#123; Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(); parameters.put(&quot;js_code&quot;, code); parameters.put(&quot;appid&quot;, appId); parameters.put(&quot;secret&quot;, secret); parameters.put(&quot;grant_type&quot;, grantType); rs = HttpClientUtils.doPost(UserService.wxjscode2sessionURL, parameters); //向微信api发送请求 &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return rs; &#125;&#125; HttpClientUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class HttpClientUtils &#123; private static final String CHARSET = &quot;utf-8&quot;; public static String doPost(String url, Map&lt;String, String&gt; map) &#123; CloseableHttpClient httpClient = null; HttpPost httpPost = null; String result = null; try &#123; httpClient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(10000).setSocketTimeout(30000).build(); httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); // 设置参数 List&lt;NameValuePair&gt; list = null; if (null != map) &#123; list = new ArrayList&lt;NameValuePair&gt;(); Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Entry&lt;String, String&gt; elem = iterator.next(); list.add(new BasicNameValuePair(elem.getKey(), elem.getValue())); &#125; &#125; if (null != list &amp;&amp; list.size() &gt; 0) &#123; UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, CHARSET); httpPost.setEntity(entity); &#125; CloseableHttpResponse response = httpClient.execute(httpPost); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == 200) &#123; if (response != null) &#123; HttpEntity resEntity = response.getEntity(); if (resEntity != null) &#123; result = EntityUtils.toString(resEntity, CHARSET); &#125; EntityUtils.consume(resEntity); response.close(); &#125; &#125; else &#123; System.err.println(&quot;HTTP POST ERROR: statusCode:&quot; + statusCode); if (response != null) &#123; HttpEntity resEntity = response.getEntity(); if (resEntity != null) &#123; String errMsg = EntityUtils.toString(resEntity, CHARSET); System.err.println(errMsg); &#125; EntityUtils.consume(resEntity); response.close(); &#125; &#125; &#125; catch (Exception ex) &#123; System.err.println(&quot;HTTP POST 请求错误：&quot; + ex.getMessage()); &#125; if (StringUtils.isNotBlank(result)) &#123; if (result.indexOf(&quot;Token_b已失效&quot;) &gt; -1) &#123; throw new RuntimeException(&quot;Token已失效,请重新登录系统！&quot;); &#125; &#125; return result; &#125;&#125; 获取 access_token参考 官方获取 access_token，获取 access_token 的方法较为简单，通过 get 请求发送到 https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 即可返回 access_token UtilService.java12345678910111213public class UtilService &#123; private final static String wxAccessTokenURL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s&quot;; public void getAccessToken (String orderFid, int type, String reason) &#123; try &#123; String url = String.format(TradeService.wxAccessTokenURL, UserService.getAppIdv2(), UserService.getSecretv2()); String rs = HttpClientUtils.doGet(url1); //获取access_token JSONObject obj = JSONObject.parseObject(rs1); String access_token = obj1.get(&quot;access_token&quot;).toString(); &#125;catch (NullPointerException e) &#123; e.printStackTrace(); &#125; &#125; HttpClientUtils.java1234567891011121314151617181920212223242526public class HttpClientUtils &#123; private static final String CHARSET = &quot;utf-8&quot;; public static String doGet(String url) &#123; String result = null; CloseableHttpClient httpclient = HttpClients.createDefault(); RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(3000).setConnectionRequestTimeout(1000).setSocketTimeout(3000).build(); HttpGet httpGet = new HttpGet(url); httpGet.setConfig(requestConfig); try &#123; CloseableHttpResponse response = httpclient.execute(httpGet); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode == 200) &#123; HttpEntity entity1 = response.getEntity(); if (entity1 != null) &#123; result = EntityUtils.toString(entity1, CHARSET); &#125; EntityUtils.consume(entity1); response.close(); &#125; &#125; catch (Exception e) &#123; System.err.println(&quot;HTTP GET 请求错误：&quot; + e.getMessage()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop入门及安装]]></title>
    <url>%2F2018%2F07%2F01%2FHadoop%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[当我们需要从 TB 甚至 PB 级别以上的数据中分析获取我们需要的信息时，如果使用传统的系统架构进行处理速度将会非常慢并且对服务器造成巨大压力。Hadoop 就是用来存储并处理这种巨大数据量的分布式架构平台。用户在该平台上可以在不需要了解底层实现细节的情况下开发高效处理大数据的程序。下面介绍 Hadoop 的一些入门知识和安装配置。转载请说明出处。 入门知识Hadoop 是什么Hadoop 是一个用来处理大数据的分布式存储和计算平台。简单来说这个平台最重要的两个作用是 存储 和 计算： 存储：分布式存储，数据被分散到多台机器上存储，由至少一台机器进行分配管理。该过程对开发人员是透明，也就是说开发人员对数据的存取过程感受不到数据是分散存储的。 计算：分布式计算，用户请求被分解成多个任务在多台机器上运行，运行结果集汇总成最终结果再返回给用户。该过程对开发人员同样是透明的。 基于以上分布式的特点 Hadoop 可以在大量廉价的机器上搭建一个分布式集群系统架构。开发人员只要先把巨大数据存储在 Hadoop 平台上，然后根据统计分析需求编写简单的处理程序。Hadoop 平台会自动把数据进行分割存储，把处理程序分解映射成多个任务分配到多台机器上进行并行计算，然后把结果集汇总返回给用户。 Hadoop 生态系统Hadoop 平台和基于该平台的相关模块框架形成一套完善的 Hadoop生态系统。该生态系统包含的组件大概如下： 在该系统中最核心的两大组件是 HDFS 和 MapReduce，这两个组件是 Hadoop 平台最早推出的体现分布式处理数据思想的组件。此外还有 YARN 资源组件。 HDFS：Hadoop Distributed File System，分布式文件存储系统。该系统把数据分割成多个部分分别存储到多台机器 (DataNode) 上，然后由一台机器 (NameNode) 进行统一组织管理。该系统只是用来管理数据的存储方式，并不存储数据。详细可参考 基本介绍 HDFS 架构采用主从架构（master/slave）。一个典型的 HDFS 集群包含一个 NameNode 节点和多个 DataNode 节点。NameNode 节点负责整个 HDFS 文件系统中的文件的元数据保管和管理，集群中通常只有一台机器上运行 NameNode 实例，DataNode 节点保存文件中的数据，集群中的机器分别运行一个 DataNode 实例。在 HDFS 中，NameNode 节点被称为名称节点，DataNode 节点被称为数据节点。DataNode 节点通过心跳机制与 NameNode 节点进行定时的通信。 MapReduce：一种用于大规模数据集并行计算的编程模型，包含两项重要函数：Map 和 Reduce。简单来说就是先通过 Map 计算把任务分发到集群多个节点上，并行计算，然后再通过 Reduce 计算把计算结果合并，从而得到最终计算结果。详细可参考 基本介绍 和 MapReduce详解 MapReduce由以下四个部分组成： Client：面向用户的接口。 用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端 用户可通过 Client 提供的一些接口查看作业运行状态 JobTracker：负责所有节点的资源监控和作业调度。主节点只有一个 JobTracker。 监控所有 TaskTracker 与 Job 的健康状况，一旦发现失败，就将相应的任务转移到其他节点。 跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源。 TaskTracker：负责本节点的资源监控和作业调度。从节点有多个 TaskTracker。 TaskTracker 会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给 JobTracker，同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等） TaskTracker 使用 slot等量划分本节点上的资源量（CPU、内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个 TaskTracker 上的空闲 slot 分配给 Task 使用。slot 分为 Map slot 和 Reduce slot 两种，分别供 MapTask 和 Reduce Task 使用 Task：分为 Map Task 和 Reduce Task 两种，均由 TaskTracker 启动 YARN：一个通用的资源管理系统，可为各类计算框架提供资源的管理和调度。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务：一个全局的资源管理器 ResourceManager 和每个应用程序特有的 ApplicationMaster。其中 ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。详细可参考 Hadoop-Yarn-框架原理及运作机制（原理篇） 和 理解Hadoop YARN架构 Hbase：一个开源的非关系型分布式数据库，可以通过廉价的机器构建集群来处理庞大的数据表，例如超过10亿行数据和数百万列元素组成的数据表。 HDFS 缺乏随机读写操作，HBase 可以用来弥补这种缺陷，其提供可以实时访问一些数据的随机读写功能。HBase 以 Google BigTable 为蓝本，以键值对的形式存储。项目的目标就是快速在主机内数十亿行数据中定位所需的数据并访问它。你可以用 Hadoop 作为静态数据仓库，HBase 作为数据存储，可以放一些需要实时访问和操作的数据。 Hive：一个数据仓库工具。可以把用户的 HiveQL（类 SQL）语句自动转换成 MapReduce 任务，这样用户就不用理解 MapReduce API 的接口内容和编写复杂的 MapReduce 程序，只需要编写简单的类 SQL 语句就可以进行数据分析。 Pig：一种数据流语言，用来快速轻松的处理巨大的数据。包含 Pig Interface 和 Pig Latin 两部分。Pig可以非常方便的处理 HDFS 和 HBase 的数据，和 Hive 类似，通过编写简单的 Pig 脚本就可以自动转换成 MapReduce 作业来处理数据。当你想做一些数据处理但又不想编写 MapReduce jobs 就可以用 Pig。 Hive 和 Pig 的区别： Hive 更适合于数据仓库的任务，Hive 主要用于静态的结构以及需要经常分析的工作。Hive 与 SQL 相似促使 其成为 Hadoop 与其他 BI 工具结合的理想交集。 Pig 赋予开发人员在大数据集领域更多的灵活性，并允许开发简洁的脚本用于转换数据流以便嵌入到较大的应用程序。 Pig 相比 Hive 相对轻量，它主要的优势是相比于直接使用Hadoop Java APIs可大幅削减代码量。正因为如此，Pig 仍然是吸引大量的软件开发人员。 Hive 和 Pig 都可以与HBase组合使用，Hive 和 Pig 还为 HBase 提供了高层语言支持，使得在 HBase 上进行数据统计处理变的非常简单 Mahout：Hadoop 平台上的数据挖掘算法库 Zookeeper：一种分布式的应用程序协调服务。随着计算节点的增多，集群成员需要彼此同步并了解去哪里访问服务和如何配置，ZooKeeper正是为此而生的。 Sqoop：Sqoop 一种数据同步和传输工具，主要用于在 Hadoop(Hive) 与传统的数据库 (mysql、postgresql…) 间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL, Oracle, Postgres等）中的数据导进到 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导进到关系型数据库中。 Flume：一种日志收集工具 Ambari：一个集群的安装和管理工具 Hadoop 安装以下配置环境 Mac OS X 10.13.2 Java 1.8.0_131 Hadoop 2.8.4 1、Java 环境在终端输入下面命令进行查看 1$ java -version 如果没有报错表示 Java 环境配置成功，否则请自行安装 Java环境，在这里不做详细介绍 2、SSH 配置在终端输入下面命令进行查看 1$ ssh localhost 如果没有报错直接显示登录时间则已经配置成功，一般来说可能会有下面两种异常情况。 用户没有权限进入 系统偏好设置 &gt; 共享 &gt; 勾选远程登录，并设置允许访问：所有用户。 还没生成 ssh 密钥可以选择 rsa 或者 dsa 协议来生成，以 rsa 协议为例 1$ ssh-keygen -t rsa 一路回车后会在 ~/.ssh 目录下生成 id_rsa 和 id_rsa.pub 两个文件，然后执行 1$ cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys 3、下载 Hadoop点击 Hadoop 官方下载地址，选择所需版本的 binary 包进行下载（source 包是源代码，binary 包是编译后的文件，一般来说我们直接使用后者即可）。以 2.8.4 版本为例，点击下载后进行解压。我的解压后安装路径为 /Users/mochuangbiao/hadoop-2.8.4 4、配置 Hadoop配置 Java 环境如果还没有配置 Java 环境，查看 JDK 安装目录 1$ /usr/libexec/java_home -V 添加该目录到环境配置文件 ~/.bash_profile 中 1export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home 配置 Hadoop 环境添加你的 Hadoop 安装目录路径到环境配置文件 ~/.bash_profile 中 12export HADOOP_HOME=/Users/mochuangbiao/hadoop-2.8.4export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin 修改 ~/.bash_profile 文件后记得执行 $ source ~/.bash_profile 使其生效 修改配置文件需要修改的配置文件一共有四个：core-site.xml、hdfs-site.xml、mapred-site.xml 和 yarn-site.xml，所有文件均位于 etc/hadoop 目录下。文件的修改均为最简单化，如需要详细配置请参考官方文档。 core-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 5、启动格式化 HDFS切换到 Hadoop 安装目录，输入命令 1$ hdfs namenode -format 启动 HDFS1$ start-dfs.sh 可能需要输入三次密码，分别用来启动 NameNode、DataNode 和 SecondaryNameNode 三个线程，访问 http://localhost:50070，能看到以下界面表示启动成功 启动 YARN1$ start-yarn.sh 可能需要输入一次到多次密码用来启动 ResourceManager 线程和 Nodemanager 线程，访问 http://localhost:8088，能看到以下界面表示启动成功 输入命令 $ jps，可以查看到以下节点信息 1234567812963 DataNode13076 SecondaryNameNode12651 ResourceManager12876 NameNode20844 Jps12748 NodeManager19885 Launcher19886 B2BApplication 停止12$ stop-yarn.sh$ stop-dfs.sh Hadoop 常用 Shell 命令调用 Hadoop Shell 命令在可使用 $ hadoop fs &lt;args&gt; 的形式（使用面最广，可以操作任何文件系统）或 $ hdfs dfs &lt;args&gt; 的形式（只能操作HDFS文件系统相关），区别可见 何时使用hadoop fs、hadoop dfs与hdfs dfs命令。常用 &lt;args&gt; 参数有： 12345678-ls #表示对hdfs下一级目录的查看 -lsr #表示对hdfs目录的递归查看 -mkdir #创建目录 -put #从linux上传文件到hdfs -get #从hdfs下载文件到linux -text #查看文件内容 -rm #表示删除文件 -rmr #表示递归删除文件 详细的可参考 Hadoop Shell 命令 注意事项 通过 HDFS 创建的目录和存储的文件以特殊的编码方式存放在机器上，不能在文件夹界面直接查看这些文件和目录，只能通过 Shell 命令来查看和操作这些文件 HDFS的根目录是 /，这个是在 HDFS 系统上的目录，与系统目录无关。默认的工作目录是 /user/$USER，USER 是你的登录用户名。使用命令 $ hdfs dfs -ls 会直接显示工作目录 /user/$USER 下的内容 使用 -mkdir 参数创建目录的时候，如果父目录不存在会报 No such file or directory 的错误。可以加上 -p 参数，如 hdfs dfs -mkdir -p /user/Hadoop/twitter_data，当路径中的某个目录不存在时会自动创建。 Hadoop 样例在这里使用 Hadoop 的 exmaple jar 包进行样例测试，该 jar 包的 wordCount 功能可用来统计一系列文本文件中每个单词出现的次数。该 jar 包的存放路径为 /Users/mochuangbiao/hadoop-2.8.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.4.jar 准备样本数据。在网上下载一些英文内容保存为 txt 格式，保存路径为 /Users/mochuangbiao/test。 创建目录。执行命令 $ hdfs dfs -mkdir input，在默认工作目录下创建 input 目录，该目录路径为 /user/mochuangbiao/input。 上传文件到 hdfs 系统。执行 $ hdfs dfs -put /Users/mochuangbiao/test/*.txt input，上传刚才的 txt 文件到 input 目录。 运行样例。执行 $ hdfs dfs /Users/mochuangbiao/hadoop-2.8.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.4.jar wordcount input output。调用 example jar 包里面的 wordcount 统计 input 目录里面的文档，统计结果自动输出到 output 文件夹。 查看结果。执行 $ hdfs dfs -ls output，一般里面会有一个类似于 part-r-00000 的文件，执行 hdfs dfs -cat output/part-r-00000 查看结果。 详细可参考 Hadoop例子——运行example中的wordCount例子 其他参考大数据学习 第一篇——基础知识Hadoop大数据生态系统及常用组件简介 数据分析：Hive、Pig和ImpalaSetting up Hadoop 2.6 on Mac OS X YosemiteMac 系统安装Hadoop 2.7.3]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客SEO优化]]></title>
    <url>%2F2018%2F06%2F29%2FHexo%E5%8D%9A%E5%AE%A2SEO%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[SEO（Search Engine Optimization）即搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名，即让搜索引擎更加容易搜索到我们的网站且结果更加靠前。当我们在网上搭建好自己的博客之后，百度、谷歌等搜索引擎并不能立即搜索到我们的博客。我们需要做一些工作来让搜索引擎更加容易搜到我们的博客。转载请说明出处。 前言为了让搜索引擎更加容易搜索到我们的博客，我们需要做的工作有： 在搜索引擎收录入口添加我们的网站（同时添加带 www 前缀的和不带 www 前缀的） 向搜索引擎推送我们的网站，谷歌可以推送 sitemap 文档，百度有主动推送、自动推送和 sitemap 文档等多种方式。 等待搜索引擎的收录。 正文hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌 这篇文章已经介绍得很详细，在这里只做部分补充。 通过 CNAME 方式验证网站上面的教程中是通过在网站根目录里面添加验证文件的方式来验证网站持有者的身份，如果你拥有独立的域名，通过 CNAME 的方法来验证会更加方便。 1、添加网站百度添加网站入口谷歌添加网站入口 添加你的域名地址，注意：最好每个搜索引擎都添加带 www 前缀和不带 www 前缀的两条记录，百度需要添加一些介绍信息之类，最后到验证网站所有权。 2、验证网站谷歌：备用方法 &gt; 域名提供商 &gt; 添加 CNAME 记录 百度：CNAME 验证 选择 CNAME 验证会得到两个网址 xxx.你的域名 和 搜索引擎验证网址（百度：ziyuan.baidu.com / 谷歌：xxx.dv.googlehosted.com），这两个网址下面需要用到。 3、域名解析添加 CNAME 记录以万网为例，进入 域名列表，点击 解析 &gt; 添加记录，记录类型选择 CNAME，主机记录前缀填写上面 xxx.你的域名 中的 xxx 前缀，解析线路默认即可，记录值填写搜索引擎验证网址，以添加谷歌验证为例： 4、完成返回刚才搜索引擎的站点管理网址，点击 验证，验证成功，如果失败过一段时间再来点击验证。 生成站点地图文件补充按照上面教程成功生成 sitemap.xml 和baidusitemap.xml 文件之后，这两个文件里面的域名默认为 http://yoursite.com，这个域名并不会自动转换成你的域名地址，直接提交给搜索引擎解析会报错，因此需要手动改成我们的域名地址，详细参考 hexo做SEO（添加sitemap和baidusitemap） 百度收录失败问题谷歌收录按照步骤完成之后一般都能正确收录，而且收录速度也很快。但是百度收录就比较难。注意：如果你的网站是搭建在 GitHub 上面，就不能被百度收录。 百度爬取 GitHub 太频繁了，甚至引起了 GitHub 的服务不稳定，最后 GitHub 直接把百度屏蔽了，百度爬虫访问直接报 403 错误。也就是说，所有托管到 GitHub Pages 上的静态博客都是无法被百度搜索到。 如果你希望你的博客能被百度收录，可以参考 百度无法爬取Github Pages静态网站解决方案]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven入门]]></title>
    <url>%2F2018%2F06%2F26%2FMaven%E5%85%A5%E9%97%A8%E5%8F%8APOM%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Maven 是基于项目对象模型 POM(project object model) 概念的的 软件项目管理工具。Maven 提供统一标准的开发项目结构，并使用简单的标签描述来配置项目相关信息和管理项目依赖包，可以使开发人员在非常短的时间内完成配置工作，大大提高开发效率。下面介绍 Maven 的一些入门知识。转载请说明出处。 MavenMaven 是什么在不借助项目管理工具的开发过程中我们通常会遇到这样的问题： 在开发中，为了保证编译通过，我们会到处去寻找 jar 包，当编译通过了，运行的时候，却发现 “ClassNotFoundException” ，我们想到的是，难道还差 jar 包？例如在 spring 框架上开发的过程中我们至少要把 spring 的常用 jar 包和依赖包 common-logging 包下载下来，然后还要加入类路径和输出目录，工作显得非常累赘。 每个 Java 项目的目录结构都没有一个统一的标准，配置文件到处都是，单元测试代码到底应该放在那里也没有一个权威的规范。 这时候就需要一个项目管理工具来对项目进行管理。Maven 是一个跨平台的项目管理工具，用于管理项目依赖，项目构建和项目生命周期的全过程。Maven 的作用有： 统一项目开发目录。例如所有的项目目录结构统一划分成 src/main/java (源代码目录)、src/main/resources (资源目录)、src/test/java (测试代码目录)、 src/test/resources (测试资源目录)、 target (生成文件目录)等目录。 统一项目的生命周期，规范项目从开始构建到部署的建设过程。 统一管理项目依赖，开发人员只需要定义所需要的依赖包，Maven 会自动搜索依赖包所依赖的其他包，不需要开发人员关心。 测试和构建流程自动化和简单化。 Maven 目录参考 Maven 标准目录布局，根据 Maven 管理工具构建的项目是有一定的目录结构标准的，这样就很好解决了文件不知道放哪里、文件目录结构杂乱无章的问题。Maven 标准的目录如下 12345678910111213141516|── pom.xml|── src| ├── main| | ├── java| | ├── resources| | └── filters| ├── test| | ├── java| | ├── resources| | └── filters| ├── it| ├── assembly| └── site├── LICENSE.txt├── NOTICE.txt└── README.txt pom.xml：Maven 的核心配置文件 src/main/java：项目的源代码所在的目录 src/main/resources：项目的资源文件所在的目录 src/main/filters：项目的资源过滤文件所在的目录 src/main/webapp：如果是web项目，则该目录是web应用源代码所在的目录，比如html文件和web.xml等都在该目录下。 src/test/java：测试代码所在的目录 src/test/resources：测试相关的资源文件所在的目录 src/test/filters：测试相关的资源过滤文件所在的目录 下面这些目录平时用的不是很多 src/it：集成测试代码所在的目录，主要是供别的插件使用的。 src/assembly：组件（Assembly）描述符所在的目录 src/site：站点描述文件 LICENSE.txt：项目的许可文件 NOTICE.txt：该项目依赖的库的注意事项 README.txt：项目的readme文件 Maven 插件插件参考 Maven Plugins。Maven 实际上是一个插件(plugin)的集成框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。 每个插件对应一到多个目标(global)，每个目标完成一个任务。Maven 的所有任务都是通过插件及其对应的目标来完成的。使用的插件语法如下： 1$ mvn [plugin-name]:[goal-name] 例如使用编译插件 (maven-compiler-plugin) 下的 compile 目标用来编译 src/main/java/ 目录下的代码，testCompile 目标用来编译 src/test/java/ 下的测试代码，命令如下： 12$ mvn compiler:compile$ mvn compiler:testCompile 参考 常用插件分析 ，在命令行输入常用的插件有： 插件 作用 maven-archetype-plugin 生成简单的 Maven 项目骨架，例如初学者常用的 mvn archetype:generate maven-compiler-plugin 编译 java 源文件，包括 main/java 和 test/java/ 目录下的 java 文件 maven-resources-plugin 处理资源文件，例如复制 main/resources 和 test/resources 下的资源文件 maven-surefire-plugin 运行 JUnit 单元测试，其实大部分时间内，只要你的测试类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在 maven-dependency-plugin 分析项目依赖并打包项目依赖到指定文件夹等 命令行输入的插件是可以在 pom.xml 文件里面配置的。pom.xml 文件里面的 &lt; build &gt; 元素对应项目的构建阶段，其中的 &lt; plugin &gt; 元素对应项目会用到的一些插件。例如下面是 pom.xml 文件常定义的的一些插件。 123456789101112131415161718192021222324252627282930313233343536&lt;build&gt; &lt;finalName&gt;MavenTest&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 插件参数在使用命令行执行 Maven 命令的时候可以加入参数执行，-D 表示配置 &lt; properties &gt; 属性，-P 表示配置 &lt; profiles &gt; 属性。 使用命令行 -D 设置 &lt; properties &gt; 属性的方式是： 1mvn -DpropertyName=propertyValue clean package 如果 propertyName 原来在 pom.xml 里面不存在，它将被设置为一个新值。 如果 propertyName 已经存在 pom.xml，例如 maven.compiler.source 这种有默认值的属性，传递的参数值会覆盖原来的属性值。 多个 -D 属性之间通过空格分开 1mvn -DpropA=valueA -DpropB=valueB -DpropC=valueC clean package 也可以在 pom.xml 文件里面通过设置 &lt; configuration &gt; 属性来设置插件属性，例如设置 JDK 的编译版本为 1.8 12345678&lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt;&lt;/plugin&gt; 总的来说，用户调用 Maven 插件目标有两种方式： 输入生命周期调用插件目标。生命周期阶段是与插件目标绑定的，这样用户只需要输入生命周期阶段就可以调用对应的插件目标，如果绑定了多个插件目标将会顺序执行。例如 Maven 默认将 maven-compiler-plugin 的 compile 目标与 compile 生命周期阶段绑定，因此命令 mvn compile 实际上是先定位到 compile 这一生命周期阶段，然后再根据绑定关系调用 maven-compiler-plugin 的 compile 目标。 直接在命令行指定要执行的插件目标。例如 mvn archetype:generate 就表示调用 maven-archetype-plugin 的 generate 目标，这种带冒号的调用方式与生命周期无关。 而 Maven 的插件参数的配置也有两种方式： 直接在命令行通过 -D 属性设置。这种相当于修改了 &lt; properties &gt; 元素的属性值。 在 pom.xml 文件的 &lt; plugin &gt; 元素里面通过 &lt; configuration &gt; 元素设置。 具体怎么配置插件参数可以参考 这里 Maven 生命周期参考 Maven Lifecycle，Maven 一共有三套生命周期 (build lifecycle)。每套生命周期会有对应的构建阶段(build phases)。运行命令执行某一个构建阶段，该阶段前面的所有阶段都会自动执行。 Maven 构建阶段和插件目标绑定。一个插件目标可以对应零到多个构建阶段，一个构建阶段可以对应零到多个插件目标，一个构建阶段如果没有绑定插件目标就不会执行。 default：构建生命周期，包括项目从验证到部署的整体流程。default 生命周期根据打包 (packaging) 类型不同（例如可以打包成 jar, war 和 pom 等），具有不同的构建阶段。下面的 jar 包的生命周期阶段： 阶段 插件:目标 目标作用 process-resources resources:resources 默认处理 src/main/resources/ 下的文件，将其输出到测试的 classpath 目录中 compile compiler:compile 编译 src/main/java 下的 java 文件，产生对应的class process-test-resources resources:testResources 默认处理 src/test/resources/ 下的文件，将其输出到测试的 classpath 目录中 test-compile compiler:testCompile 编译 src/test/java 下的 java 文件，产生对应的 class test surefire:test 运行测试用例 package jar:jar 打包构件，即生成对应的 jar, war 等 install install:install 将构件部署到本地仓库 deploy deploy:deploy 部署构件到远程仓库 clean：清理生命周期，清空目标文件，也就是清空 target 文件夹。 阶段 插件:目标 clean clean:clean site：生成项目描述网站周期，产生项目的站点描述文件。 阶段 插件:目标 作用 site site:site 产生项目的站点文档 site-deploy site:deploy 将项目的站点文档部署到服务器 POMpom.xml 文件是整个 Maven 项目的核心配置文件。pom.xml 文件记录了整个项目的基础配置信息、相关依赖插件、构建配置和远程库等信息。 整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 基本设置 --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;properties&gt;...&lt;/properties&gt; &lt;!-- 构建过程的设置 --&gt; &lt;build&gt;...&lt;/build&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;!-- 项目信息设置 --&gt; &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;url&gt;...&lt;/url&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;!-- 环境设置 --&gt; &lt;issueManagement&gt;...&lt;/issueManagement&gt; &lt;ciManagement&gt;...&lt;/ciManagement&gt; &lt;mailingLists&gt;...&lt;/mailingLists&gt; &lt;scm&gt;...&lt;/scm&gt; &lt;prerequisites&gt;...&lt;/prerequisites&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;profiles&gt;...&lt;/profiles&gt;&lt;/project&gt; 常用标签modelVersion必须，POM 模型版本，一般写 4.0.0 版本，该版本是同时被 Maven2 和 Maven3 支持的版本。 groupId必须，组织唯一标识，通常写法是 com.mycompany.app，同时定义了构建时生成的相对路径为 /com/mycompany/app。 artifactId必须，项目名称唯一标识，写法如 consumer-banking version必须，项目版本，写法如 2.3.4 groupId、artifactId 和 version 是所有 POM 文件根节点 &lt;project&gt; 里面必须包含的三个字段，共同定义了该项目在仓库里面的坐标位置，这意味着特定的 groupId 下，artifactId 也必须是唯一的。 version 定义为 1.0.0 和 1.0.0-SNAPSHOT 的区别：1.0.0是指稳定版本，只要版本号不变，就算远程库中该版本号的项目进行了更新，也不会去远程库中拉取最新版本的项目，除非把版本号改成 1.1.0 等不同版本号；1.0.0-SNAPSHOT 是指开发版本，每次建立项目时都会去远程库中查看是否有最新版本。 packaging项目的打包类型，可以为 jar、war、ear、pom 等。 dependencies定义了项目相关的所有依赖，每一个依赖包由 &lt;dependency&gt; 包围，&lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt; 标签定义了依赖包在仓库中的唯一坐标，Maven 根据该坐标按照 本地仓库 &gt; 中央仓库 &gt; 远程仓库 的查找顺序去查找依赖包。 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; parent父项目坐标，类似于 java 的集成，将继承父项目的依赖和插件等。在这里继承父项目的依赖有两种方式： 第一种：完全继承父项目的所有依赖。子项目将引入父项目的所有依赖。 父项目使用 元素引入依赖，如 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt; &lt;!-- spring 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 子项目通过设置 为父项目的坐标即可继承父项目的所有依赖 123456&lt;parent&gt; &lt;groupId&gt;com.youzhibing.account&lt;/groupId&gt; &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- 与不配置一样，默认就是寻找上级目录下得pom.xml --&gt;&lt;/parent&gt; 第二种：继承父类的依赖，但是只是作为一个范围约束，只有子项目通过 &lt; dependency &gt; 显示引入该范围内的依赖才算真正引入。这种继承方式更加灵活，而且子项目的 &lt; dependency &gt; 里面不需要说明 version 版本号，可以在父项目里面统一管理版本号。 父项目通过 &lt; dependencyManagement &gt; 限制依赖范围。123456789101112131415161718192021222324252627282930313233&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt; &lt;!-- spring 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 子类引入父项目的依赖范围，通过 &lt; dependency &gt; 真正引入依赖，不用添加版本号。 12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;com.youzhibing.account&lt;/groupId&gt; &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!--真正引入 spring 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bulid项目的构建信息 finalName：构建产生的项目名称，默认为 ${artifactId}-${version}。 directory：构建产生的文件的存放目录，默认为 $(basedir}/target ，即项目根目录下的 target 目录。 plugins：插件列表，如下面第一个插件指定 Maven 插件编译版本，使用 java8 语言，JVM1.8 编译，编译时使用UTF-8编码。 resources：项目资源列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。如下面就把文件 version.txt、banner.txt 和 templates/index.html 打包到 target 目录 12345678910111213141516171819202122232425262728293031323334&lt;build&gt; &lt;finalName&gt;sale-api&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;version.txt&lt;/include&gt; &lt;include&gt;banner.txt&lt;/include&gt; &lt;include&gt;templates/index.html&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; propertiesPOM 定义的常量，可供 POM 文件的其他地方引用，格式是 &lt;name&gt;value&lt;/name&gt;，引用时通过 ${name} 来获取 value 的值。 Maven 总共有 6 类属性，内置属性、POM 属性、settings 属性、java 系统属性、env 环境变量属性和自定义属性。 内置属性：两个常用内置属性 ${basedir} 表示项目根目录，即包含 pom.xml 文件的目录；${version} 表示项目版本。 POM 属性：用户可以使用该类属性引用 POM 文件中对应元素的值。如 ${project.artifactId} 就对应了 xxx 元素的值，常用的POM属性包括：${project.build.sourceDirectory}:项目的主源码目录，默认为src/main/java/ ${project.build.testSourceDirectory}:项目的测试源码目录，默认为src/test/java/ ${project.build.directory} ： 项目构建输出目录，默认为target/ ${project.outputDirectory} : 项目主代码编译输出目录，默认为target/classes/ ${project.testOutputDirectory}：项目测试主代码输出目录，默认为target/testclasses/ ${project.groupId}：项目的groupId ${project.artifactId}：项目的artifactId ${project.version}：项目的version,与${version} 等价 ${project.build.finalName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version} settings 属性：以 settings. 开头的属性，引用 settings.xml 文件中的 XML 元素的值。 java 属性：以 java. 开头的属性，可引用java 系统属性，如${java.home}指向了 java 根目录。 env 属性：以 env. 开头的属性，可使用所有环境变量属性，如 ${env.JAVA_HOME} 指代了 JAVA_HOME 环境变量的的值。 自定义属性。可在其他地方通过 ${} 来引用该属性。 例如下面就定义了 java 属性的版本号，并自定义了一个 file.encoding 属性。12345&lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file_encoding&gt; &lt;java.source.version&gt;1.5&lt;/java_source_version&gt; &lt;java.target.version&gt;1.5&lt;/java_target_version&gt; &lt;/properties&gt; repositories远程仓库列表，当 Maven 在本地仓库和中央仓库中找不到所需要的依赖包时就会去远程仓库查找，可通过 &lt;repository&gt; 定义多个远程仓库。 123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;name&gt;Spring Releases&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;org.jboss.repository.releases&lt;/id&gt; &lt;name&gt;JBoss Maven Release Repository&lt;/name&gt; &lt;url&gt;https://repository.jboss.org/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 根 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符 --&gt; &lt;artifactId /&gt; &lt;!--被继承的父项目的全球唯一标识符 --&gt; &lt;groupId /&gt; &lt;!--被继承的父项目的版本 --&gt; &lt;version /&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目的名称, Maven产生的文档用 --&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven&gt;&lt;/maven&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息 --&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory /&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory /&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory /&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory /&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory /&gt; &lt;!--使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!--构建扩展的groupId --&gt; &lt;groupId /&gt; &lt;!--构建扩展的artifactId --&gt; &lt;artifactId /&gt; &lt;!--构建扩展的版本 --&gt; &lt;version /&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal /&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录 --&gt; &lt;directory /&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName /&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters /&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表 --&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;!-- 以下为插件示例 --&gt; &lt;!-- 指定maven插件编译版本，使用java8语言，JVM1.8编译，编译时使用UTF-8编码 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 启动jar插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;classifier&gt;server&lt;/classifier&gt; &lt;mainClass&gt;com.xx.xxxx.server.startup.StmsStartup&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id /&gt; &lt;!-- 声明变量，当该profile被激活时，可以用$&#123;env&#125;引入值 --&gt; &lt;properties&gt; &lt;!-- env为key（自定义的），相当于声明变量:env=dev --&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志 --&gt; &lt;activeByDefault /&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt; &lt;jdk /&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;) --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory /&gt; &lt;finalName /&gt; &lt;filters /&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports /&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules&gt;&lt;/modules&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--报表插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的报表插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--报表插件的配置 --&gt; &lt;configuration /&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id /&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports /&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties&gt;&lt;/properties&gt;&lt;/project&gt; 参考Maven 官方文档Maven 详解Maven学习-目录结构Maven 的 pom 文件详细解析Maven 中 pom 文件详解maven常用插件解析]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用学习网址汇总]]></title>
    <url>%2F2018%2F06%2F25%2F%E7%BD%91%E5%9D%80%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[在学习的过程中遇到很多有实用干货的文章和一些很实用的工具性网站，如果每读完一篇博客后都要写一篇博客来进行知识总结未免太耗费时间，在这里将这些实用的文章和工具性网站进行汇总，方便以后查找资料。 系统LinuxLinux命令大全 编程语言JAVA官方文档Java8 官方手册Java8 官方手册中文版-谷歌版Java8 官方手册中文版-有道版Java8 官方手册中文版-百度版 安装入门MAC 安装 JDK 及环境变量配置 字符串探秘Java中的String、StringBuilder以及StringBuffer 网络HttpURLConnection与HttpClient浅析 异常Java中的异常和处理详解 数据库PostgreSQLPostgreSQL 官方文档PostgreSQL 教程-易百教程在 Mac OS X 上安装 PostgreSQL Mongodb介绍一款好用 mongodb 可视化工具 实用工具Git常用 Git 命令清单Git 工作流程Git 使用规范流程廖雪峰 Git 教程 HadoopHadoop 2.7.3 官方文档Hadoop 中文文档Hadoop学习笔记—1.基本介绍与环境配置 MavenMaven 官方文档Maven 中央仓库Maven 教程-易百教程Mac 安装 MavenMaven 详解 MarkdownMarkdown 官方中文手册Markdown 语法整理大集合2017Markdown 语法手册 （完整整理版）]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo问题及解决办法汇总]]></title>
    <url>%2F2018%2F06%2F25%2FHexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[对通过 Hexo 搭建博客过程中遇到的问题进行了汇总，以后再遇到相同的问题可以迅速定位解决问题。 搜索问题点击 Local Search 本地搜索页面卡住问题描述：安装教程配置好 Local Search 本地搜索之后，点击 搜索 按钮页面一直卡在转圈圈的地方，F12进入开发者工具没有看到错误提示，以 debug 模式启动的服务器也没有错误输出？ 问题解决：出现这种情况是因为你的某一篇文章中出现了非 UTF-8 编码的字符，解决办法是 找到把该异常字符并删除。 打开 http://localhost:4000/search.xml，确认错误字符所在的位置。如下图所示就在 第6行第35列 通过 $ vim public/search.xml 打开 search.xml 文件，根据刚才的位置定位到出现问题的文章的该行该列。该位置一般会出现一个异常字符，例如 ^H 或者 ^M 等字符。注意不用直接修改 search.xml 文件。 编辑出现问题的文章的 md 文件，找到出现问题的行列，把该位置的特殊字符删掉。该字符有可能是一个隐藏的字符如 ^H，一般的 markdown 编辑工具可能看不到该字符，可以通过 vim 编辑删除该字符。 执行 $ hexo clean &amp;&amp; hexo g 后重启服务器，然后再打开 http://localhost:4000/search.xml，看到下图所示表示可以正常使用本地搜索功能。 部署问题在执行 hexo d 部署到 GitHub 上的时候总是卡住问题描述：在执行 hexo d 部署到 GitHub 上的时候总是卡住没有往下面执行，这时候只能 ctrl + c 中断或等待很久一段时间后才执行完毕。 问题解决：这是由于国内墙对 GitHub 的阻挡影响，导致国内用户在向 GitHub 仓库 pull 或者 push 的时候速度都会受到不同程度的影响。解决办法是 买或者自己搭建个 vpn，然后设置 git 代理。 1234567891011121314// 查看当前代理设置git config --global http.proxygit config --global https.proxy// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080git config --global http.proxy &apos;http://127.0.0.1:1080&apos;git config --global https.proxy &apos;http://127.0.0.1:1080&apos;git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;// 删除 proxygit config --global --unset http.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序自定义tabBar]]></title>
    <url>%2F2018%2F06%2F25%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89tabBar%2F</url>
    <content type="text"><![CDATA[tabBar 是指小程序底部的导航栏，微信小程序官方提供了 多 tabBar 设置，但是官方提供的 tabBar 最多支持 5 个 tab，而且是全局共用的，这意味着并不支持 有时候我们想跳到不同的页面显示不同的 tabBar 导航栏 这样的功能。所以本人尝试着手实现自定义的 tabBar 导航栏。转载请说明出处。 实现思路参考过网上自定义 tabBar 的一些资料，例如这位仁兄的 微信小程序自定义tabBar组件开发，发现大部分资料都是 通过 navigateTo 的方式进行 tab 切换。这种实现方式有一个很明显的缺点：在 tab 切换的时候整个页面都会刷新一次，这意味着页面底下的 tabBar 导航栏也会跟着刷新，这样会很影响用户体验。官网的 tabBar 导航栏是在底层实现，所以不会出现这种刷新情况。 因为没有办法解决这种通过 navigateTo 实现 tabBar 的刷新问题，本人转换了一种思路。这种办法适合于每个 tab 页面数据量不是很大的情况，如果你每个页面的数据量都非常大而且需要实时刷新的话可能不太适合这种方法。 所有的 tab 页面和底下 tabBar 导航栏都写在同一个 wxml 页面里面，每个 tab 页面跟导航栏的一个按钮对应。 在打开页面时所有 tab 页面的数据通过一个路由取回，然后渲染到各个 tab 页面里面。然后只把第一个 tab 页面的内容显示出来，其他 tab 页面都隐藏。 每次点击下面的 tabBar 导航栏，只把点击按钮对应的 tab 页面显示出来，其他的 tab 页面都隐藏。 这样实现的好处是 tab 切换时底部导航栏不会刷新，而且切换非常流畅，缺点是切换时 tab 页面不能实现实时刷新。如果你觉得这种实现方法能满足你的需求，请继续往下看。 实现过程下面显示每部分的核心代码。 wxml12345678910111213141516171819202122232425&lt;view class=&apos;container&apos;&gt; &lt;view class=&apos;del-list&apos;&gt; &lt;view class=&quot;page__bd&quot;&gt; &lt;block wx:if=&apos;&#123;&#123;tabbarIndex == 0&#125;&#125;&apos;&gt; // tab 页面1代码 &lt;/block&gt; &lt;block wx:if=&apos;&#123;&#123;tabbarIndex == 1&#125;&#125;&apos;&gt; // tab 页面2代码 &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!--自定义导航栏--&gt; &lt;view class=&apos;tabbar&apos;&gt; &lt;view class=&apos;tabbar-box&apos;&gt; &lt;view class=&apos;tabbar-item&apos; wx:for=&quot;&#123;&#123;tabbarList&#125;&#125;&quot; bindtap=&apos;tapTabbar&apos; id=&quot;&#123;&#123;item.index&#125;&#125;&quot;&gt; &lt;view class=&apos;tabbar-item-icon&apos;&gt; &lt;image src=&apos;&#123;&#123;item.icon&#125;&#125;&apos;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&apos;tabbar-item-text&apos;&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 底部导航栏为 tabbarList 的一个 list 数组，每个 tab 页面的 tabbarIndex 跟 list 数组的 index 对应。这样就可以根据 index 来显示对应的 tab 页面。 js12345678910111213141516171819202122232425262728293031323334353637383940414243444546Page(&#123; data: &#123; ...... tabbarList: [&#123; index: 0, icon: &apos;/images/driver/deliver-select.png&apos;, text: &apos;发货单&apos; &#125;, &#123; index: 1, icon: &apos;/images/driver/my.png&apos;, text: &apos;我的&apos; &#125;], tabbarIndex: 0, &#125;, /** * 点击tabbar导航栏 */ tapTabbar: function(e) &#123; var index = e.currentTarget.id var tabbarList = this.data.tabbarList for (var item in tabbarList) &#123; if (tabbarList[item].index == index) &#123; var icon = tabbarList[item].icon var iconList = icon.split(&apos;.&apos;) if(iconList[0].indexOf(&apos;select&apos;) &lt; 0) &#123; tabbarList[item].icon = iconList[0] + &apos;-select.&apos; + iconList[1] &#125; &#125;else &#123; var icon = tabbarList[item].icon var iconList = icon.split(&apos;.&apos;) if (iconList[0].indexOf(&apos;select&apos;) &gt; 0) &#123; var temp = iconList[0].replace(/-select/g, &apos;&apos;) tabbarList[item].icon = temp + &apos;.&apos; + iconList[1] &#125; &#125; &#125; this.setData(&#123; tabbarList: tabbarList, tabbarIndex: index &#125;) &#125;, ......&#125;) 点击 tabBar 导航栏时，把当前点击按钮的图片更新为带 -select 后缀表示选中的图片，其他的按钮图片更新为无后缀图片，然后重新渲染 tabbarList 和 tabbarIndex。 wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445.......tabbar &#123; position: fixed; z-index: 999; bottom: 0; width: 100%; height: 120rpx; background-color: #f8f8f8; border-top: 1rpx solid #d9d9d9&#125;.tabbar-box &#123; display: flex; align-items: center; justify-content: center&#125;.tabbar-item &#123; display: flex; flex-direction: column; text-align: center; justify-content: center; margin-top: 10rpx; width: 50%&#125;.tabbar-item image &#123; width: 65rpx; height: 65rpx;&#125;.tabbar-item-icon &#123; height: 65rpx&#125;.tabbar-item-text &#123; font-size: 28rpx; color: #999&#125;.del-list-logout &#123; width: 90%; margin: 50rpx auto 0&#125; tabBar 图片 实现效果]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客绑定域名]]></title>
    <url>%2F2018%2F06%2F24%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Hexo + Github 搭建的个人博客访问地址默认为 yourname.github.io，这种地址一方面由于太长不容易被人记住，另一方面也难以被谷歌、百度等搜索引擎收录。所以我们可以申请独立的域名指向我们的博客地址，转载请说明出处。 域名目前国内有万网、新网等域名服务商，下面以 万网 为例子说明 购买域名登陆 万网官网，申请阿里云账号，然后在 域名注册 页面购买自己的域名 按照工信部 2017 年全面域名实名认证的要求,若域名在规定时间内未通过实名审核，会被注册局暂停解析（Serverhold），无法正常访问，待实名认证通过后方可恢复正常使用。实名认证流程为： 登录 阿里云域名控制台，单击 域名列表 页面的 未实名认证域名 &gt; 提交资料 。 填写实名认证资料，单击 提交 。 域名解析在 域名列表 里面找到你注册成功且通过实名认证可正常使用的域名，点击 解析 按钮（未实名认证状态异常的域名可能没有该按钮） 在 解析设置 界面点击右上角 添加记录，填写内容 记录类型：CNAME 类型将该域名指向你的 yourname.github.io，也可以用 A类型指向 ip 地址：先 ping 你的 yourusername.github.io，用 A 类型指向 ping 得到的 ip 地址。 主机记录：www 解析后的域名为 www.aliyun.com, @ 直接解析主域名 aliyun.com。一般写这两个就行。 记录值：CNAME 解析对应 yourname.github.io，A 解析对应 ip 地址。 添加成功后如下图所示： Hexo我们要在上传到 GitHub 的静态文件夹里面添加 CNAME 解析文件，对应上面添加的 CNAME 解析记录。 创建 CNAME 文件我们在站点目录的 source 文件夹下面创建 CNAME 文件，这样每次我们生成静态文件的时候都会自动把该文件添加到 public 文件夹。 12$ cd source$ vim CNAME 注意文件名就是 CNAME，不能写错，在文件中添加你注册的域名如下 1mcbill.cn 注意域名前面不用加任何前缀，保存退出。 发布部署1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署成功再过几分钟访问你的域名，如 mcbill.cn 解析成功就会跳转到你的博客。以后就算是直接访问 yourname.github.io 也会直接解析为你的域名。至此 绑定域名已经完成。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo多台电脑更新博客]]></title>
    <url>%2F2018%2F06%2F22%2FHexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[通过 Hexo 和 GitHub 搭建的博客，静态文件会上传到 GitHub 仓库的 master 分支，但是 Hexo 的安装目录还是保存在本地的。如果更换了电脑需要更新博客，我们需要 Hexo 的安装目录来生成/编辑/上传博客，并且这个安装目录需要随着博客的更新而更新。在这里提供一种便捷的办法来实现不同电脑之间同步更新博客。转载请说明出处。 实现思路在 Github 用于存放博客的仓库 yourname.github.io 下面建立 master 和 hexo 两个分支 master 分支（默认创建），通过 Hexo 命令提交，用于存放上传的 Hexo 静态文件（例如 public 文件夹里面的内容），这个分支用于显示 https://yourname.github.io 打开的内容。 hexo 分支（手动创建），通过 Git 命令提交/拉取，用于存放 Hexo 的安装目录，该分支可设为 默认分支 。 这样我们写博客的大概流程就是 在 hexo 分支上写上博客，并把写好的博客内容上传到 master 分支，两个分支都通过 git 进行管理，所有的修改一目了然，非常方便。 实现过程本地电脑如果你的电脑还没配置好 Hexo，请参考以前的教程 Hexo+GitHub搭建个人博客教程当你本地电脑的 Hexo 目录已经安装配置完毕之后，该目录可以 通过 Hexo 命令向 GitHub 仓库的 master 分支提交内容，但是该目录还不是 git 管理的目录，需要把该目录初始化为 git 管理的目录。 1、删除非默认主题文件的 .git 目录（可跳过）如果你使用的是非默认主题 landscape 的其他主题，而该主题的目录也是在通过 git clone 方式拉取下来的话，需要先取消该目录的 git 管理追踪，否则到时候提交 Hexo 安装目录的时候该文件夹会报类似于 XXX目录: git modified content untracked content 的错误。例如本人使用的是 next 主题，在 Hexo 安装目录下输入命令： 1234$ cd themes/next$ ls -la # 显示 .git 的隐藏目录$ rm -rf .git$ ls -la # 确认 .git 目录是否成功删除 2、把 Hexo 命令提交的分支改成 master 分支编辑 Hexo 安装目录下的 _config.yaml 文件，在 deploy 参数里面添加 branch: master，如下 1234deploy: type: git repo: https://github.com/yourusername/yourusername.github.io.git branch: master 3、初始化 git 仓库在 Hexo 安装目录下输入命令 1234$ git init$ git checkout -b hexo$ git add .$ git commit -m &apos;init&apos; 初始化为 git 目录并创建 hexo 分支 4、提交到远端服务器在 Hexo 安装目录下输入命令 12$ git remote add origin git@github.com:yourusername/yourusername.github.io.git$ git push -u origin hexo:hexo 与远端主机关联并提交 hexo 分支 另外一台电脑当你在一台新电脑上需要写博客的时候，需要先把 hexo 分支拉取下来，再进行 Hexo 初始化。前提是该电脑需要先安装 git 和 node.js，并与 GitHub 进行 ssh 关联（可选）。如果这些工作还没完成请参考 Hexo+GitHub搭建个人博客教程 1、拉取 hexo 分支在任意目录里面输入命令 1$ git clone -b hexo git@github.com: yourusername/yourusername.github.io.git 执行完之后你的目录下应该会出现一个 yourusername.github.io 的目录。 2、初始化为 Hexo 目录yourusername.github.io 目录只是一个普通的 git 管理目录，需要把该目录初始化为 Hexo 目录。 1234$ cd yourusername.github.io$ npm install hexo$ npm install$ npm install hexo-deployer-git 3、安装插件（可跳过）1234$ npm install hexo-generator-searchdb --save # 本地搜索插件$ npm install hexo-asset-image --save # 图片插件$ npm install hexo-generator-sitemap --save # 谷歌站点地图插件$ npm install hexo-generator-baidu-sitemap --save # 百度站点地图插件 至此这台新电脑的初始化工作也已经完成，可以开始写博客了。 写博客步骤以后我们写博客都在 hexo 分支下进行，master 分支只是用来存放生成的静态文件。确认目前在 hexo 分支下，步骤如下： git pull 每次写博客前拉取最新的 hexo 分支代码 hexo new post &#39;新文章&#39; 开始写博客 hexo clean &amp;&amp; hexo g 清空并生成新的静态文件和缓存文件 git add . git commit -m &#39;备注&#39; git push 提交到 hexo 分支 hexo d 提交到 master 分支 至此我们就可以实现在多台电脑上同步更新博客 参考资料Git远程操作详解GitHub Pages + Hexo搭建博客原git中status指令总是提示内容被修改的解决hexo本地测试运行重启后页面空白]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入图片和设置图片大小]]></title>
    <url>%2F2018%2F06%2F21%2Fhexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[Hexo 插入图片有两种方式，第一种是网络引用，第二种是本地插入，本文主要介绍本地插入图片方式。另外由于 Hexo 是静态博客框架，所插入的图片默认会按照本身大小自动铺满，如果要设置图片大小需要另外写 css 来进行控制。转载请说明出处。 前言Hexo 插入图片有 网络图片插入 和 本地图片插入 两种方式。 网络图片插入的做法是先把图片上传到 七牛云 等云服务商提供的图床，然后通过 ![img-title](img-url) 的方式，把 img-url 的地址替换成图片在图床的 url 地址即可。使用网络图片的好处是七牛云的cdn加速效果会大大提高图片的打开速度，缺点是多图片博客的编辑过程会比较繁琐，图片管理比较麻烦。 本地图片插入把图片和博客保存在一起，方便图片管理，但是图片的网络打开速度会很慢。下面重点介绍本地图片插入。 常规本地图片插入1、修改配置文件编辑 hexo安装目录下的_config.yml 文件，找到 post_asset_folder，把值改成 true。 通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开资源文件管理功能。当资源文件管理功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2、安装插件安装插件 hexo-asset-image，在 hexo 安装目录下运行 1$ npm install hexo-asset-image --save 安装完成后需要重启一下服务器 3、使用插入图片使用 hexo new post &quot;xxxx&quot; 来新建博客时，会发现在 /source/_posts 文件夹下会有一个同名的 xxxx 文件夹，对于已存在的博客可以新建一个同名文件夹。 先把图片复制到同名文件夹中，然后在文章中使用 1![图片替代文字](img.jpg) 注意 img.jpg 前面的路径只需要同名文件夹的名称即可，不需要写什么绝对路径、相对路径。如我要引用 example.jpeg 图片，只需要把 example.jpeg 复制到同名文件夹，然后在文章中使用 1![赵霁](example.jpeg) 效果图如下： 设置图片大小图片默认会显示原本的图片大小并居中显示，如果需要对图片大小进行设置，需要另外写 css 样式进行控制。注意：该方法可能会覆盖原来的一些图片样式。 1&lt;div style=&quot;width: 200px; margin: auto&quot;&gt;![赵霁](example.jpeg)&lt;/div&gt; 设置宽度为200px并设置居中（高度会自动缩放），效果图如下： 参考Hexo 官方文档资源文件夹hexo博客图片问题hexo生成博文插入图片]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序自定义Modal组件]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89Modal%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在小程序 官方文档 中可以使用 wx.showModal() 方法来生成 Modal 蒙层弹框，但是其显示的内容只能为文本格式且由传入参数限定，显示方式比较单一，不能满足日常多样化的需求。本人查阅了相关资料完成一些自定义Modal组件，可以满足个性化需求。转载请说明出处。 实现思路在这里的实现思路主要是通过微信小程序的原生 Modal 组件来实现，这个组件在最新版的官方文档中已经找不到，估计官方是想用 wx.showModal() 方法来代替使用，但是仍然可以向下兼容使用。通过原生的 Modal 组件我们可以自定义自己的内容界面，Modal 组件的 api 文档如下 再对比 wx.showModal() 的 api 文档不难看出其只是对 Modal 组件的进一步封装。 源码wxml1234567891011121314151617181920212223242526272829......&lt;!--打印发货单蒙层--&gt; &lt;modal hidden=&quot;&#123;&#123;hideModal&#125;&#125;&quot; class=&apos;modal&apos; cancel-text=&apos;返回&apos; confirm-text=&apos;下一步&apos; bindcancel=&quot;cancelPrint&quot; bindconfirm=&quot;confirmPrint&quot; catchtouchmove=&apos;preventTouchMove&apos;&gt; &lt;view class=&apos;modal-box&apos;&gt; &lt;radio-group bindchange=&apos;radioChange&apos;&gt; &lt;label class=&apos;radio modal-item&apos;&gt; &lt;view class=&apos;modal-item-hd&apos;&gt; &lt;radio value=&apos;1&apos; checked=&apos;&#123;&#123;radioIndex == 1&#125;&#125;&apos;&gt;&lt;/radio&gt; &lt;view&gt;根据手机号和提货码发货&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;modal-item-bd&apos;&gt; &lt;view&gt;手机号：&#123;&#123;phone&#125;&#125;&lt;/view&gt; &lt;view&gt;提货码：&#123;&#123;detail.ladingCode&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/label&gt; &lt;label class=&apos;radio modal-item&apos;&gt; &lt;view class=&apos;modal-item-hd&apos;&gt; &lt;radio value=&apos;2&apos;&gt;&lt;/radio&gt; &lt;view&gt;扫描二维码&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;modal-item-bd&apos;&gt; &lt;view&gt;请点击下一步&lt;/view&gt; &lt;/view&gt; &lt;/label&gt; &lt;/radio-group&gt; &lt;/view&gt; &lt;/modal&gt;...... wxml文件最关键部分是 &lt;modal&gt;&lt;/modal&gt; 组件的调用，参数解析如下 通过 hidden 属性来控制蒙层的显示和隐藏 bindcancel 属性绑定返回时间 bindconfirm 属性绑定确认事件 catchtouchmove 防止触摸滑动穿透，即当 modal 弹层下的页面有滚动条，在 modal 弹层上触摸滑动时下面的页面仍跟着滚动的情况。 js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263data: &#123; phone: null, detail: null, hideModal: true, radioIndex: 1&#125;,....../** * 显示modal组件 */printDel: function() &#123; this.setData(&#123; hideModal: false &#125;)&#125;,/** * 隐藏modal组件 */cancelPrint: function() &#123; this.setData(&#123; hideModal: true &#125;)&#125;,/** * 阻断蒙层事件向下传递 */preventTouchMove: function() &#123;&#125;/** * 选择打印发货单方式 */radioChange: function(e) &#123; this.setData(&#123; radioIndex: e.detail.value &#125;)&#125;,/** * 确认打印 */confirmPrint: function() &#123; var radioIndex = this.data.radioIndex if(radioIndex == 1) &#123; //根据手机号和提货码发货 wx.showToast(&#123; title: &apos;请在终端屏幕上输入手机号和提货码&apos;, icon: &apos;none&apos; &#125;) &#125;else &#123; //扫描二维码 /** code */ this.setData(&#123; hideModal: true &#125;) &#125;&#125;,.... js 文件中最关键的是 this.setData({ hideModal: true / false }) 来控制 Modal 组件的隐藏/显示，以及空方法 preventTouchMove() 阻止事件向父节点传递。 以bind或catch开头，然后跟上事件的类型，bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。 详见 小程序事件 wxss12345678910111213141516171819.......modal-item-hd &#123; display: flex; align-items: center&#125;.modal-item-hd view &#123; font-size: 32rpx; color: #000; padding-top: 5rpx&#125;.modal-item-bd &#123; margin: 10rpx 0 20rpx 60rpx; font-size: 36rpx;&#125;...... wxss比较简单，在这里不做详细解析。 最终效果 参考文档自定义模态对话框实例微信小程序之—-弹框组件modal小程序 实现遮罩层]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>Modal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题配置]]></title>
    <url>%2F2018%2F06%2F17%2Fnext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NexT 是 Hexo 下最热门的主题之一，下面简单简介 NextT 主题的配置，在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。转载请说明出处。 一、安装NextT1、下载主题把主题文件下载到安装目录的 theme 目录下12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2、启用主题打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 注意：修改 站点配置文件 需求重启服务器才能生效，修改 主题配置文件 不需要重启服务器。重启步骤为在服务器启动控制台 ctrl + c，然后 $ hexo server [--debug] 二、主题设置1、外观 scheme 设置修改 主题配置文件，查找 scheme 关键字，将你需用启用的 scheme 前面注释 # 去除即可 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 紧凑集中版双栏 Scheme，本网站采用的主题 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 2、语言 language 设置编辑 站点配置文件 （针对所有主题下的文件）或 主题配置文件 (针对本主题下的文件)下的 language，例如启用简体中文就改成 zh-Hans1language: zh-Hans 3、设置菜单启用/禁用菜单编辑 主题配置文件，设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。把需要启动的菜单项前面的 # 去掉。也可以新增自定义菜单项。 123456789menu: home: / || home # about: /about/ || user tags: /tags/ || tags categories: /categories/ || th # archives: /archives/ || archive # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat 默认的菜单项如下： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 schedule schedule: /schedule 日程表 about about: /about 关于 sitemap sitemap: /sitemap 站点地图 commonweal commonweal: /404.html 公益 404 其中除了 home 和 archives 页面，其他页面都需要手动创建，例如新建 tags 页面 切换到 Hexo 根目录下，使用 hexo new page tags 新建 tags 页面 编辑 /source/tags/index.md 文件，在头文件部分 front-matter 添加 type: &quot;tags&quot;，如需要关闭评论添加 comments: false 设置菜单显示文字修改 languages/{language}.yml 文件，如果简体中文对应 languages/zh-Hans.yml 文件下的 menu 字段 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 修改字段值直接影响页面上菜单文字显示，或者新增字段值，字段名要与上面第一步设置的自定义菜单名称对应。 4、设置侧栏修改 主题配置文件 文件中的 sidebar 字段 设置侧栏位置 left - 靠左放置 right - 靠右放置 12sidebar: position: left 设置侧栏显示的时机 post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 12sidebar: display: post 5、设置头像修改 主题配置文件 下的 avatar 字段，设成头像的链接1avatar: images/avatar.png 6、设置作者昵称编辑 站点配置文件，设置 author 字段 7、设置站点名称编辑 站点配置文件，设置 description 字段 8、设置社交编辑 主题配置文件 设置社交链接修改 social 字段，其键值格式是 显示文本: 链接地址。 1234567891011social: GitHub: https://github.com/18814122746 || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 设置链接图标修改 social_icons: 字段，其键值格式是 匹配键: Font Awesome 图标名称，匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配） 1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 9、设置背景动画NexT 自带 canvas_nest 和 three_waves 两种背景动画效果，编辑 主题配置文件 将对应的字段改成 true 或 false 即可，只能同时开启一种背景动画效果。 12canvas_nest: true#three_waves : false 三、第三方插件1、安装评论系统理论上 Hexo 支持 DISQUS、Facebook Comments、HyperComments、Gitment、网易云跟帖、搜狐畅言、友言和来必力等评论插件，其中 DISQUS、Facebook Comments 需要翻墙才能评论，Hypercomments 目前只剩下收费版本，Gitment 需要用 GitHub 账号登陆才能评论，搜狐畅言 需要网站备案才能使用，网易云跟帖、友言 已经停止服务。综合考虑选择 来必力 作为我们的评论系统。 登陆 来必力官网 注册账号 点击 右上角头像 &gt; 管理页面，安装 City 免费版 打开 管理页面 中的 代码管理，复制 data-uid 中的值 编辑 主题配置文件 中的 livere_uid 字段，把刚才复制的 data-uid 的值粘贴进去 2、统计访问次数有 百度统计 和 不蒜子 统计两种方式。两者的区别是：前者可以用来后台统计，数据比较准确可靠；后者用来在页面上显示，根据访问 ip 进行粗略统计。 百度统计 登陆 百度统计官网，注册账号 获取代码点击 管理 &gt; 代码管理 &gt; 代码获取，找到类似于 hm.src = &quot;https://hm.baidu.com/hm.js?xxx&quot;; 的代码，复制 .js? 后面的统计脚本id 编辑 主题配置文件 中的 baidu_analytics 字段，把刚才粘贴的值粘贴进去 不蒜子统计编辑 主题配置文件 中的 busuanzi_count 参数，如下所示 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 总访问人数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 本文阅读量 page_pv_footer: 次 当 site_uv: true 时，代表在页面底部显示站点的UV值。 当 site_pv: true 时，代表在页面底部显示站点的PV值。 当 page_pv: true 时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 pv的方式，单个用户连续点击n篇文章，记录n次访问量。uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 3、百度分享编辑 主题配置文件 中的baidushare 字段，改成 123baidushare: type: button baidushare: true 注意：百度分享不支持 Https，打开开发工具控制台可能会看到 Failed to load resource 的错误信息，原因是通过 Https 请求百度分享的 Http 资源时候被拒绝了。解决办法是直接把这些百度分享的资源文件放到自己的目录下，参考大佬的解决方案 百度分享不支持https的解决方案 下载资源文件，GitHub地址为 https://github.com/hrwhisper/baiduShare 把里面的 static 文件夹放在安装目录下的 source 文件夹里面 修改 你的安装目录/themes/next/layout/_partials/share/baidushare.swig 文件如下 123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 编辑 站点配置文件 中的 skip_render 字段，Hexo会禁止编译 skip_render 定义的文件/文件夹 1skip_render: static/** 重启服务器，最好执行一下 hexo clean 4、本地搜索 Local Search 安装 hexo-generator-searchdb，在安装目录下执行 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，查找 local_search 字段，把值改为 true 12local_search: enable: true 四、参考Hexo中文使用文档Hexo的Next主题详细配置hexo的next主题个性化教程：打造炫酷网站hexo添加评论功能hexo next主题为博客添加分享功能 Hexo+Github搭建个人博客(三)——百度分享集成为NexT主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客教程]]></title>
    <url>%2F2018%2F06%2F13%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一款基于 Node.js 的支持 Markdown 的静态站点生成框架，利用 Hexo+GitHub 可以轻松打造属于个人的免费博客。经过本人一番摸索最终搭建成功。本人的博客地址为 飙戈的博客，欢迎大家前来指导，转载请说明出处。 一、环境配置在搭建之前电脑需要的环境配置如下： git node.js github pages 仓库 我们可以在控制台中输入 12$ node -v$ git --version 如果没有报错则说明git和node.js已经安装成功，可直接跳过安装教程，如果报错则需要重新安装 1、安装git windows 用户：直接下载git安装程序根据提示进行安装 mac 用户：通过homebrew进行安装，没有安装的需要先安装homebrew，可以通过命令 $ brew install git 安装，也可通过下载 git安装程序 进行安装 linux 用户：通过命令行安装 $ sudo apt-get install git-core 安装完成后再在控制台输入 1$ git --version 如果没有报错则说明安装成功 2、安装node.js1）下载安装程序（推荐）直接下载 node.js安装程序 进行安装，比较快捷省事，适用于 mac 和 windows 用户 2）使用nvm安装cURL: 1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 安装完成后再在控制台输入 $ node -v 如果没有报错则说明安装成功 3、github pages我们用来托管博客的服务叫做 Github Pages，它是 Github 用来提供给个人/组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。 1）申请github账号首先你需要申请注册一个 github 账号 2）创建托管仓库点击右上角 New Repository 新建一个仓库来作为托管仓库，注意命名为 username.github.io（username是你的账号名)。 GitHub Pages 有两种类型：User/Organization Pages 和 Project Pages，两者的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 一般搭建个人博客都是用 User Pages，所以命名需要按照规范命名。 3）配置SSH（可跳过）SSH实现本地 git 项目和远程 github 的连接，github 通过 SSH 密钥识别特定的可信任电脑，该部分电脑在向 github 推送的时候不需要输入用户名和密码 查看电脑是否已经配置 ssh key 1$ ls -al ~/.ssh 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。如果提示 No such file or directory 则说明未安装 第一次安装完 git 需要先 初始化配置 git（可跳过） 12git config –global user.name &quot;yourusername&quot;git config --global user.email &quot;youremail@example.com&quot; 生成新的 SSH Key，输入密码之类的可以省略，一路回车就行 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 复制执行命令后显示的 key 内容 1cat ~/.ssh/id_rsa.pub 点击右上角的 Settings –&gt; SSH and GPG keys –&gt; New SSH key ，Title 自由填写，Key 粘贴刚才复制的那段代码，点击 Add SSH Key 测试连接 1$ ssh -T git@github.com 如果看到 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入yes，回车看到 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 表示连接成功，ssh的配置至此完成 二、安装Hexohexo的安装相当简单，在确保以上环境已经配置好的情况下 1、下载Hexo1$ npm install -g hexo-cli 有些教程会用命令 $ npm install -g hexo，作用同上，均为下载Hexo的安装包 2、初始化安装执行以下命令Hexo可把文件安装到指定文件夹 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建一个名为的文件夹（可带路径），通过 hexo init 初始化该文件夹，然后切换到该文件夹中，执行 npm install 进行安装 3、目录如果以上的安装成功，在安装目录下将会出现以下的文件结构 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的全局配置文件 package.json：应用程序的信息 scaffolds：模版文件夹，Hexo的模板是指在新建的markdown文件中默认填充的内容。当您新建文章时，Hexo 会根据 scaffold 来建立文件。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source：资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。例如用于域名解析的 CNAME 文件就可以放到该文件夹中，每次部署的时候都会自动添加该文件。 themes：主题文件夹，Hexo 会根据主题来生成静态页面。 三、使用Hexo1、启动输入命令 1$ hexo server 进行启动，可简化为 $ hexo s ，也可启动调试模式 $ hexo server --debug 启动完成后访问地址：http://localhost:4000/ 2、创建文章执行以下命令可新建文章 1$ hexo new [layout] &lt;title&gt; 1）布局（layout）hexo有三种默认布局，用户也可以自定义布局，不同布局对应不同的存储路径 post：一般文章布局，自定义布局和post的对应的存储路径为 source/_posts page：页面布局，例如可以用于生成标签（tags）或分类（categories）等主页面，就是点击菜单直接显示的页面，对应的存储路径为 source draft：草稿布局，草稿默认不会显示在页面上，已完成的草稿可用 $ hexo publish [layout] &lt;title&gt; 来发布，对应的存储路径为 source/_drafts 2）标题（title）Hexo 默认以标题做为文件名称，可以设置配置文件的 new_post_name 参数来改变默认的文件名称，例如设为 :year-:month-:day-:title.md ，文件名会带上年月日，其中 :title 默认会转为小写，空格将会被替换为短杠 例如执行命令 1$ hexo new post &quot;hello world&quot; source/_posts下面会自动生成一个名为 2019-08-02-hello-world.md 文件。 3、编辑文章文章编辑可以用普通的markdown编辑器，例如本人习惯使用typora编辑器。 文章内容分为前页（Front-matter）和正文 1）前页Front-matter 是文章头部 — 分隔符上方的区域，可以设置的变量有： layout：布局 title：标题 date：建立日期，默认为文件建立日期 updated：更新日期，默认为文件更新日期 comments：开启文章的评论功能，默认为true tags：标签，不适用于布局为 page 的的页面 categories：分类，不适用于布局为 page 的的页面 permalink：覆盖文章网址 categories和tags的区别：categories具有顺序性和层次性，例如 1234&gt; categories:&gt; - Diary&gt; - Life&gt; 会使 Life 成为 Diary 的子类，而不是并列分类。 tags没有顺序和层次。 前页实例： 1234567891011---title: hello-worlddate: 2018-06-10 16:15:04categories:- Diary- Lifetags:- happy- friendcomments: false--- 创建一篇文章题目为hello-world，文章创建时间是2018-06-10 16:15:04，分类归为Diary的子分类Life，贴上happy和friend两个标签，最后禁止评论 2）正文正文和普通的markdown编辑相同，在这里有一些使用技巧。 首页显示部分内容。首页默认会显示全部文章的全部内容，很多情况下我们只想在首页显示每篇文章的序言等部分内容，这样有利于读者总览。我们只需要在文章添加一句 &lt;!--more--&gt; ，例如 123文章内容1&lt;!--more--&gt;文章内容2 &lt;!--more--&gt; 以上的内容1会在首页正常显示，以下的内容2会隐藏，并显示 阅读全文 等链接。 编辑字体颜色。Hexo 通过 &lt;font&gt; 标签可实现自定义字体颜色和大小，color 属性定义字体颜色（不带引号），size 定义字体大小，例如粉色字体 1&lt;font color=#BF3EFF size=3&gt;粉色字体&lt;/font&gt; 4、发布文章我们在本地编辑的文章只能在本地查看，如果想把文章发布到网上，我们需要把文章上传到上面配置好的 github pages 中。在发布文章前我们需要进行一些配置。 1）配置_config.yml文件编辑安装目录下的 _config.yml 文件，找到 deploy 参数，把 type 改成 git，repo 改成你自己的仓库地址，该地址可以直接上 github 上获取。 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/18814122746/18814122746.github.io.git 注意：type: 和 git之间必须带一个空格 2）安装deployer工具hexo-deployer-git 为hexo自动部署安装工具，可通过命令安装 1$ npm install hexo-deployer-git --save 3）开始发布发布文章可分为 清空、生成 和 部署 三部分 清空。清除缓存文件 (db.json) 和已生成的静态文件 (public) 1$ hexo clean 生成。生成public静态文件夹 1$ hexo generate 也可简化成 $ hexo g 部署。部署到 github 上面 1$ hexo deploy 也可简化成 $ hexo d 执行完以上命令后，在浏览器输入 https://username.github.io 就可以浏览你的刚才发布的博客，例如本人的博客网址为 https://18814122746.github.io/ ，至此 Hexo + Github 的个人博客搭建已经完成。 5、Hexo常用命令汇总123456789$ hexo init [folder] #初始化 folder 文件夹为网站根目录，如果没有 folder 默认在目前的文件夹初始化$ hexo new &lt;title&gt; #新建文章$ hexo new page &lt;title&gt; #新建页面$ hexo server #启动服务器，默认情况下，访问网址为： http://localhost:4000/$ hexo clean #清空静态文件和缓存文件$ hexo generate #生成静态文件到public目录，可简写为 hexo -g$ hexo deploy #部署文件到远程服务器，可简写为 hexo -d$ hexo help #查看帮助$ hexo version #查看Hexo的版本 上述命令行可指定模式运行，有三种模式： 安全模式。在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 1$ hexo --safe 调试模式。在终端中显示调试信息并记录到 debug.log。 1$ hexo --debug 简洁模式 1$ hexo --silent 例如以调试模式启动服务器： $ hexo s --debug 参考链接Hexo官方中文文档HEXO搭建个人博客搭建个人博客-hexo+github详细完整步骤如何搭建一个独立博客——简明Github Pages与Hexo教程GitHub Pages + Hexo搭建博客使用Hexo搭建个人静态博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
